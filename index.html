<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conscious 3D Agent AI — Enhanced & Optimized v4.0</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* --- General Page Styles --- */
        :root {
            --bg-dark: #0a0a15;
            --bg-gradient-start: #0a0a15;
            --bg-gradient-end: #1a0a2e;
            --primary-blue: #4af;
            --primary-blue-glow: rgba(68, 170, 255, 0.6); /* Slightly less intense glow */
            --secondary-dark: rgba(10, 10, 30, 0.95); /* Slightly darker for better contrast */
            --border-dark: #2a2a4a;
            --text-light: #e0e0e0;
            --text-medium: #aaa;
            --text-dark: #888;
            --error-red: #ff6b6b;
            --warn-orange: #ffa726;
            --info-green: #4CAF50;
            --connection-positive: rgba(0, 255, 153, 0.7); /* Greenish for positive weights */
            --connection-negative: rgba(255, 100, 100, 0.7); /* Reddish for negative weights */
            --connection-neutral: rgba(100, 100, 100, 0.4); /* Gray for small weights */
        }

        body {
            margin: 0;
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            font-family: 'Courier Prime', monospace;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
            color: var(--primary-blue);
            box-sizing: border-box;
            overflow-y: auto;
            overflow-x: hidden;
            line-height: 1.5;
            font-size: 16px; /* Base font size */
        }
        .main-container {
            display: flex;
            flex-direction: column;
            max-width: 1400px;
            width: 100%;
            margin: 0 auto;
            padding: 0;
            gap: 20px;
        }
        /* --- Header Styles --- */
        .header {
            text-align: center;
            background: var(--secondary-dark);
            border-radius: 12px;
            padding: 20px;
            border: 2px solid var(--primary-blue);
            box-shadow: 0 0 30px var(--primary-blue-glow);
            will-change: transform, box-shadow;
            transition: all 0.3s ease-in-out;
        }
        .header:hover {
            transform: translateY(-3px);
            box-shadow: 0 0 40px var(--primary-blue-glow);
        }
        .header h1 {
            margin: 0;
            color: var(--primary-blue);
            text-shadow: 0 0 20px var(--primary-blue-glow);
            font-size: 2.5em;
            letter-spacing: 1px;
        }
        .header p {
            margin: 10px 0 0;
            color: var(--text-medium);
            font-size: 1.1em;
        }
        /* --- Content Layout --- */
        .content-section {
            display: flex;
            flex-direction: row;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: stretch;
        }
        /* --- Metrics Panel (Left, Full Height and Width) --- */
        .metrics-panel {
            flex: 0 0 400px;
            background: var(--secondary-dark);
            border-radius: 12px;
            border: 1px solid var(--border-dark);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            height: 100%; /* Important for stretch */
            min-height: 80vh; /* Minimum height for scroll */
            overflow-y: auto;
            position: relative;
        }
        .metrics-panel h3 {
            margin-top: 0;
            color: var(--primary-blue);
            border-bottom: 2px solid var(--primary-blue);
            padding-bottom: 8px;
            font-size: 1.25em;
            letter-spacing: 0.5px;
        }
        .metric {
            display: flex;
            justify-content: space-between;
            margin: 6px 0;
            padding: 3px 0;
            font-size: 1.05em;
            border-bottom: 1px dashed rgba(68, 170, 255, 0.1);
        }
        .metric:last-of-type {
            border-bottom: none;
        }
        .metric-label {
            color: var(--text-medium);
            flex-shrink: 0;
        }
        .metric-value {
            font-weight: bold;
            color: var(--text-light);
            text-align: right;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .qualia-bar-container {
            height: 22px;
            margin: 6px 0;
            border: 1px solid #333;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
            background: #000;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
        }
        .qualia-bar {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s ease-out;
            position: relative;
            width: 0%;
            will-change: width;
        }
        .qualia-being { background: linear-gradient(90deg, #ff6b6b, #e74c3c); }
        .qualia-intent { background: linear-gradient(90deg, #4ecdc4, #1abc9c); }
        .qualia-existence { background: linear-gradient(90deg, #a855f7, #9b59b6); }
        .qualia-emergence { background: linear-gradient(90deg, #f97316, #e67e22); }
        .qualia-gestalt { background: linear-gradient(90deg, #3b82f6, #3498db); }
        .qualia-context { background: linear-gradient(90deg, #14b8a6, #2ecc71); }
        .qualia-rel-emergence { background: linear-gradient(90deg, #ec4899, #e91e63); }
        .qualia-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 0.2) 50%, rgba(255, 255, 255, 0) 100%);
            animation: qualiaWave 2s infinite linear;
            mix-blend-mode: overlay;
        }
        @keyframes qualiaWave {
            from { transform: translateX(-100%); }
            to { transform: translateX(100%); }
        }
        .qualia-label, .qualia-value {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            color: #fff;
            font-size: 13px;
            font-weight: bold;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.9);
            pointer-events: none;
            z-index: 2; /* Ensure label/value are above the bar and its pseudo-element */
        }
        .qualia-label { left: 8px; }
        .qualia-value { right: 8px; }

        .phi-display {
            text-align: center;
            font-size: 22px;
            font-weight: bold;
            margin: 15px 0;
            padding: 10px;
            border-radius: 10px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: #fff;
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.5);
            letter-spacing: 1px;
        }
        .framework-badge {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 13px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .status {
            color: var(--primary-blue);
            text-align: center;
            font-size: 17px;
            font-weight: bold;
            margin-bottom: 10px;
            border-bottom: none !important;
        }
        .stability-gauge {
            width: 100%;
            height: 18px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            overflow: hidden;
            margin: 10px 0;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
        }
        .stability-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--error-red), var(--warn-orange), var(--info-green));
            width: 0%;
            transition: width 0.5s ease-out;
            will-change: width;
        }
        .slider-container {
            margin: 10px 0;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .slider-label {
            font-size: 14px;
            color: var(--primary-blue);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #2a2a2a;
            border-radius: 5px;
            outline: none;
            opacity: 0.8;
            transition: opacity .2s;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.5);
        }
        input[type="range"]:hover {
            opacity: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-blue);
            cursor: grab;
            box-shadow: 0 0 5px var(--primary-blue-glow);
            transition: background 0.2s ease;
        }
        input[type="range"]::-webkit-slider-thumb:active {
            cursor: grabbing;
            background: #6af;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-blue);
            cursor: grab;
            box-shadow: 0 0 5px var(--primary-blue-glow);
        }

        /* Flash animation for tuned parameters */
        @keyframes param-flash {
            0% { background-color: transparent; }
            30% { background-color: rgba(68, 170, 255, 0.3); }
            60% { background-color: transparent; }
            100% { background-color: transparent; }
        }
        .param-flash-active {
            animation: param-flash 1s ease-out;
        }

        .sheaf-graph {
            position: relative;
            height: 160px;
            width: 100%;
            margin: 15px 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            box-shadow: inset 0 0 8px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        .sheaf-vertex-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .vertex {
            width: 40px; /* Adjusted size */
            height: 24px; /* Adjusted size */
            border-radius: 4px; /* Rectangular */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px; /* Adjusted font size */
            font-weight: bold;
            transition: all 0.2s ease;
            position: absolute;
            color: white;
            z-index: 10;
            background: radial-gradient(circle, #ff6b6b, #e74c3c);
            box-shadow: 0 0 8px rgba(255,107,107,0.5);
            cursor: help;
            will-change: transform, box-shadow;
            padding: 2px;
            box-sizing: border-box;
            text-align: center;
        }
        .vertex.active {
            animation: pulse 1.5s infinite;
            background: radial-gradient(circle, #00ff99, #00cc66);
            box-shadow: 0 0 12px rgba(0,255,153,0.8), 0 0 20px rgba(0,255,153,0.4);
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        .theoretical-info {
            margin-top: 15px;
            font-size: 11px;
            color: var(--text-dark);
            background: rgba(0, 0, 0, 0.1);
            padding: 10px;
            border-radius: 6px;
            white-space: pre-wrap;
            overflow-x: auto;
        }
        /* --- Right Column (Game + Visualizers) --- */
        .right-column {
            display: flex;
            flex-direction: column;
            gap: 20px;
            flex: 1;
            min-width: 550px;
        }
        .game-container {
            width: 100%;
            background: var(--secondary-dark);
            border-radius: 12px;
            border: 1px solid var(--border-dark);
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }
        #gameCanvas {
            width: 100%;
            height: auto;
            aspect-ratio: 16 / 9; /* Adjusted for a more cinematic 3D view */
            background: #000; /* Black background for 3D rendering */
            border: 1px solid #333;
            border-radius: 6px;
            margin-bottom: 12px;
            image-rendering: auto; /* Changed from pixelated */
        }
        .score-container {
            display: flex;
            justify-content: space-around;
            gap: 20px;
            width: 100%;
            padding: 5px 0;
            border-top: 1px solid var(--border-dark);
        }
        .score-metric {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 1.2em;
        }
        .score-metric .metric-label {
            color: var(--text-medium);
            font-size: 0.8em;
            margin-bottom: 3px;
        }
        .player-score .metric-value {
            color: #ff9900;
            font-size: 1.5em;
        }
        .ai-score .metric-value {
            color: #44aaff;
            font-size: 1.5em;
        }
        /* --- Visualizer Column (Stacked) --- */
        .visualizer-row {
            display: flex;
            flex-direction: column;
            gap: 20px;
            justify-content: flex-start;
            flex-grow: 1;
        }
        .panel {
            background: var(--secondary-dark);
            border: 1px solid var(--border-dark);
            border-radius: 10px;
            padding: 15px;
            box-sizing: border-box;
            width: 100%;
            position: relative;
        }
        .panel h3 {
            margin-top: 0;
            color: var(--primary-blue);
            border-bottom: 2px solid var(--primary-blue);
            padding-bottom: 8px;
            font-size: 1.18em;
        }
        .panel p {
            font-size: 13px;
            color: var(--text-medium);
            margin-top: -5px;
            margin-bottom: 12px;
            text-align: center;
        }
        .nn-visualizer-panel {
            min-height: 120px;
            display: flex;
            flex-direction: column;
            flex-grow: 1;
        }
        #nn-visualization-container, #nn-visualization-container-opponent {
            position: relative;
            flex-grow: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 15px;
            min-height: 80px;
        }
        .nn-layer {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            height: 100%;
            align-items: center;
            gap: 6px;
            z-index: 10;
            position: relative;
            min-height: 60px;
        }
        .nn-neuron {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            border: 1px solid #888;
            background: #333;
            transition: background-color 0.1s ease-out, border-color 0.1s ease-out, box-shadow 0.1s ease-out;
            flex-shrink: 0;
            box-shadow: 0 0 3px rgba(0,0,0,0.5);
            will-change: background-color, border-color, box-shadow;
        }
        .nn-neuron.active-action {
            animation: pulse-action 0.8s infinite alternate;
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.9), 0 0 12px rgba(0, 255, 255, 0.5);
        }
        @keyframes pulse-action {
            from { transform: scale(1); opacity: 1; }
            to { transform: scale(1.2); opacity: 0.8; }
        }
        .nn-connections-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            opacity: 0.7;
        }
        .neuron-flash {
            animation: neuron-flash-anim 0.8s ease-out forwards;
        }
        @keyframes neuron-flash-anim {
            0% { transform: scale(1.0); box-shadow: 0 0 10px rgba(255, 255, 255, 0.8); }
            50% { transform: scale(1.3); box-shadow: 0 0 15px rgba(0, 255, 153, 0.9), 0 0 20px rgba(0, 255, 153, 0.5); }
            100% { transform: scale(1.0); box-shadow: 0 0 5px rgba(0, 255, 153, 0.3); }
        }
        /* --- Controls & Log --- */
        .controls-section {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            margin: 10px 0;
            padding: 10px 0;
            border-top: 1px solid var(--border-dark);
            border-bottom: 1px solid var(--border-dark);
        }
        button {
            background: linear-gradient(135deg, #2a2a4a, #3a3a5a);
            color: var(--text-light);
            border: 1px solid #555;
            padding: 10px 18px;
            cursor: pointer;
            border-radius: 8px;
            font-family: inherit;
            transition: all 0.2s ease;
            font-weight: bold;
            min-width: 140px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            font-size: 1.05em;
        }
        button:hover {
            background: linear-gradient(135deg, #3a3a5a, #4a4a6a);
            box-shadow: 0 4px 15px var(--primary-blue-glow);
            transform: translateY(-2px);
            border-color: var(--primary-blue);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px var(--primary-blue-glow);
        }
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: #2a2a4a;
            box-shadow: none;
        }
        button.active {
            background: linear-gradient(135deg, #5a5a7a, #6a6a8a);
            box-shadow: 0 0 15px var(--primary-blue-glow);
            transform: translateY(0px);
            border-color: var(--primary-blue);
            color: #fff;
        }
        .difficulty-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }
        .difficulty-controls label {
            color: var(--text-medium);
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .difficulty-controls input[type="number"] {
            width: 60px;
            padding: 5px;
            border-radius: 44px;
            border: 1px solid var(--border-dark);
            background-color: #1a1a2e;
            color: var(--text-light);
            font-family: inherit;
            text-align: center;
        }
        .log-container {
            flex-basis: 100%;
            background: var(--secondary-dark);
            border-radius: 12px;
            border: 1px solid var(--border-dark);
            padding: 15px;
        }
        #log {
            background: #1e1e1e;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 12px;
            height: 150px;
            overflow-y: auto;
            font-family: 'Courier Prime', monospace;
            font-size: 12px;
            color: #ccc;
            white-space: pre-wrap;
            word-break: break-all;
            line-height: 1.4;
        }
        .log-entry {
            margin-bottom: 2px;
        }
        .log-entry.error { color: var(--error-red); }
        .log-entry.warn { color: var(--warn-orange); }
        .log-entry.info { color: var(--info-green); }

        /* --- Loading Overlay --- */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.5em;
            font-weight: bold;
            border-radius: 12px;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        .loading-overlay.active {
            opacity: 1;
            pointer-events: all;
        }
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--primary-blue);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .loading-text {
            font-size: 0.8em;
            color: var(--text-medium);
        }

        /* --- Performance Chart Styles --- */
        .performance-charts-container {
            background: var(--secondary-dark);
            border-radius: 12px;
            border: 1px solid var(--border-dark);
            padding: 15px;
            margin-top: 20px;
        }
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }
        .chart-container {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 10px;
        }
        .chart-container h4 {
            margin: 0 0 10px 0;
            font-size: 1em;
            text-align: center;
            color: var(--primary-blue);
        }
        .chart-svg {
            width: 100%;
            height: 120px;
        }

        /* --- Qualia Attention Styles --- */
        .qualia-attention-panel {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 10px;
            margin-top: 15px;
        }
        .qualia-attention-panel h4 {
            margin: 0 0 10px 0;
            font-size: 1.1em;
            text-align: center;
            color: var(--primary-blue);
        }
        .attention-bar-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
            font-size: 12px;
        }
        .attention-label {
            width: 110px;
            color: var(--text-medium);
            text-align: right;
            flex-shrink: 0;
        }
        .attention-bar-wrapper {
            flex-grow: 1;
            height: 14px;
            background: #111;
            border: 1px solid #333;
            border-radius: 3px;
        }
        .attention-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            border-radius: 2px;
            transition: width 0.3s ease-out;
        }

        /* --- Responsive Design --- */
        @media (max-width: 1200px) {
            .content-section {
                flex-direction: column;
                align-items: center;
            }
            .metrics-panel {
                flex: 0 0 auto;
                width: 100%;
                max-width: 800px;
                min-height: auto;
            }
            .right-column {
                min-width: unset;
                width: 100%;
                max-width: 800px;
            }
        }
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            .header h1 {
                font-size: 1.8em;
            }
            .header p {
                font-size: 0.9em;
            }
            .metrics-panel, .game-container, .panel, .log-container, .performance-charts-container {
                padding: 10px;
            }
            .metrics-panel h3, .panel h3 {
                font-size: 1.1em;
            }
            .phi-display {
                font-size: 1.5em;
                padding: 8px;
            }
            button {
                min-width: unset;
                flex-grow: 1;
                font-size: 0.9em;
            }
            .score-metric {
                font-size: 1em;
            }
            .player-score .metric-value, .ai-score .metric-value {
                font-size: 1.2em;
            }
            .charts-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body role="document">
    <div class="main-container" role="main">
        <div class="header" role="banner">
            <h1>🧠 Conscious 3D Agent AI — Enhanced & Optimized v4.0</h1>
            <p>A dual-AI task navigating a complex environment with obstacles, using a Hierarchical, Recurrent, Reinforcement Learning Architecture.</p>
        </div>
        <div class="content-section">
            <div class="metrics-panel" role="complementary" aria-labelledby="oftcc-metrics-heading">
                <h3 id="oftcc-metrics-heading">OFTCC Metrics</h3>
                <div class="framework-badge">
                     RL ⊕ Recurrent OWM ⊕ Meta-Learning
                </div>
                <div class="status" id="status" aria-live="polite" aria-atomic="true">
                    Initializing...
                </div>
                <div class="phi-display" id="phi-display" aria-live="polite" aria-atomic="true">
                    Φ: 0.000
                 </div>
                <div class="btn-group">
                    <button id="toggleSimButton" aria-label="Toggle simulation run/pause (Spacebar)">🚀 Toggle Simulation</button>
                    <button id="resetSimButton" aria-label="Reset game and AI to initial state (R key)">🔄 Reset All</button>
                    <button id="tuneButton" aria-label="Tune AI parameters adaptively (T key)">⚙️ Tune</button>
                </div>
                <div class="qualia-viz" role="region" aria-labelledby="qualia-dynamics-heading">
                    <h3 id="qualia-dynamics-heading" class="status">Qualia Diffusion Dynamics</h3>
                    <div class="qualia-bar-container" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="Being Qualia Level">
                        <div class="qualia-bar qualia-being" id="qualia-being-fill"></div>
                        <span class="qualia-label">Being</span>
                        <span class="qualia-value" id="being-value">0.00</span>
                    </div>
                    <div class="qualia-bar-container" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="Intent Qualia Level">
                        <div class="qualia-bar qualia-intent" id="qualia-intent-fill"></div>
                        <span class="qualia-label">Intent</span>
                        <span class="qualia-value" id="intent-value">0.00</span>
                    </div>
                    <div class="qualia-bar-container" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="Existence Qualia Level">
                        <div class="qualia-bar qualia-existence" id="qualia-existence-fill"></div>
                        <span class="qualia-label">Existence</span>
                        <span class="qualia-value" id="existence-value">0.00</span>
                    </div>
                    <div class="qualia-bar-container" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="Emergence Qualia Level">
                        <div class="qualia-bar qualia-emergence" id="qualia-emergence-fill"></div>
                        <span class="qualia-label">Emergence</span>
                        <span class="qualia-value" id="emergence-value">0.00</span>
                    </div>
                    <div class="qualia-bar-container" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="Gestalt Qualia Level">
                        <div class="qualia-bar qualia-gestalt" id="qualia-gestalt-fill"></div>
                        <span class="qualia-label">Gestalt</span>
                        <span class="qualia-value" id="gestalt-value">0.00</span>
                    </div>
                    <div class="qualia-bar-container" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="Context Qualia Level">
                        <div class="qualia-bar qualia-context" id="qualia-context-fill"></div>
                        <span class="qualia-label">Context</span>
                        <span class="qualia-value" id="context-value">0.00</span>
                    </div>
                    <div class="qualia-bar-container" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="Relational Emergence Qualia Level">
                        <div class="qualia-bar qualia-rel-emergence" id="qualia-rel-emergence-fill"></div>
                        <span class="qualia-label">Rel. Emergence</span>
                        <span class="qualia-value" id="rel-emergence-value">0.00</span>
                    </div>
                </div>
                <div class="metric-group" role="group" aria-labelledby="metric-group-heading">
                    <h3 id="metric-group-heading" class="status">System Metrics</h3>
                    <div class="metric"><span class="metric-label">Free Energy F:</span><span class="metric-value" id="free-energy" aria-live="polite" aria-atomic="true">0.000</span></div>
                    <div class="metric"><span class="metric-label">Prediction Error:</span><span class="metric-value" id="prediction-error" aria-live="polite" aria-atomic="true">0.000</span></div>
                    <div class="metric"><span class="metric-label">Gestalt Unity:</span><span class="metric-value" id="gestalt-unity" aria-live="polite" aria-atomic="true">0.000</span></div>
                    <div class="metric"><span class="metric-label">dim H¹:</span><span class="metric-value" id="h1-dimension" aria-live="polite" aria-atomic="true">0.00</span></div>
                    <div class="metric"><span class="metric-label">Gluing Inconsistency:</span><span class="metric-value" id="inconsistency" aria-live="polite" aria-atomic="true">0.000</span></div>
                    <div class="metric"><span class="metric-label">Learning Rate:</span><span class="metric-value" id="learning-rate" aria-live="polite" aria-atomic="true">0.0000</span></div>
                    <div class="metric"><span class="metric-label">Epsilon (Exploration):</span><span class="metric-value" id="epsilon-value" aria-live="polite" aria-atomic="true">0.000</span></div>
                </div>
                <div class="qualia-attention-panel" id="qualiaAttentionPanel" role="region" aria-labelledby="qualia-attention-heading">
                    <h4 id="qualia-attention-heading">Qualia Attention (Main AI)</h4>
                </div>
                <div class="sheaf-graph" id="sheafGraph" role="img" aria-label="Sheaf graph visualizing information flow between concepts">
                    <canvas id="sheafGraphCanvas" class="sheaf-vertex-canvas" aria-hidden="true"></canvas>
                    <div class="vertex" id="vertex-0" aria-label="Agent X Position">Agent-X</div>
                    <div class="vertex" id="vertex-1" aria-label="Agent Z Position">Agent-Z</div>
                    <div class="vertex" id="vertex-2" aria-label="Agent Rotation">Agent-Rot</div>
                    <div class="vertex" id="vertex-3" aria-label="Target X Position">Target-X</div>
                    <div class="vertex" id="vertex-4" aria-label="Target Z Position">Target-Z</div>
                    <div class="vertex" id="vertex-5" aria-label="Vector to Target X">Vec-DX</div>
                    <div class="vertex" id="vertex-6" aria-label="Vector to Target Z">Vec-DZ</div>
                    <div class="vertex" id="vertex-7" aria-label="Distance to Target">Dist-Target</div>
                </div>
                <div class="metric-group" role="group" aria-labelledby="system-stability-heading">
                    <h3 id="system-stability-heading" class="status">System Stability</h3>
                    <div class="stability-gauge" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="System Stability">
                        <div class="stability-fill" id="stability-fill"></div>
                    </div>
                    <div class="slider-container">
                        <label class="slider-label" for="alphaSlider">α Parameter: <span class="metric-value" id="alpha-param">0.500</span></label>
                        <input type="range" id="alphaSlider" min="0.01" max="1" step="0.01" value="0.5" aria-labelledby="alphaSlider-label" aria-valuetext="0.500">
                    </div>
                    <div class="slider-container">
                        <label class="slider-label" for="betaSlider">β Parameter: <span class="metric-value" id="beta-param">0.500</span></label>
                        <input type="range" id="betaSlider" min="0.01" max="1" step="0.01" value="0.5" aria-labelledby="betaSlider-label" aria-valuetext="0.500">
                    </div>
                    <div class="slider-container">
                        <label class="slider-label" for="gammaSlider">γ Parameter: <span class="metric-value" id="gamma-param">0.100</span></label>
                        <input type="range" id="gammaSlider" min="0.01" max="0.5" step="0.01" value="0.1" aria-labelledby="gammaSlider-label" aria-valuetext="0.100">
                    </div>
                </div>
                <div class="loading-overlay" id="metricsLoadingOverlay" aria-live="assertive" aria-busy="true" aria-label="Loading metrics and computations">
                    <div class="loading-spinner"></div>
                    <div class="loading-text" id="metricsLoadingText">Processing...</div>
                </div>
            </div>
            <div class="right-column">
                <div class="game-container panel" role="region" aria-labelledby="game-env-heading">
                    <h3 id="game-env-heading">🤖 3D Agent Environment</h3>
                    <canvas id="gameCanvas" role="img" aria-label="3D Game Environment with two AI agents navigating to targets"></canvas>
                    <div class="score-container">
                        <div class="score-metric player-score">
                            <span class="metric-label">Opponent Targets Collected:</span>
                            <span id="player-score" class="metric-value" aria-live="polite" aria-atomic="true">0</span>
                        </div>
                        <div class="score-metric ai-score">
                            <span class="metric-label">Main AI Targets Collected:</span>
                            <span id="ai-score" class="metric-value" aria-live="polite" aria-atomic="true">0</span>
                        </div>
                    </div>
                    <div class="loading-overlay" id="gameLoadingOverlay" aria-live="assertive" aria-busy="true" aria-label="Loading game and AI">
                        <div class="loading-spinner"></div>
                        <div class="loading-text" id="gameLoadingText">Setting up game...</div>
                    </div>
                </div>
                <div class="visualizer-row">
                    <div class="nn-visualizer-panel panel" role="region" aria-labelledby="player-brain-heading">
                        <h3 id="player-brain-heading">🤖 Opponent AI Brain</h3>
                        <p>This AI learns independently using its own ontological world model.</p>
                        <div id="nn-visualization-container-opponent"></div>
                        <div class="loading-overlay" id="opponentBrainLoadingOverlay" aria-live="assertive" aria-busy="true" aria-label="Loading opponent AI brain">
                            <div class="loading-spinner"></div>
                            <div class="loading-text" id="opponentBrainLoadingText">Initializing opponent model...</div>
                        </div>
                    </div>
                    <div class="nn-visualizer-panel panel" role="region" aria-labelledby="main-ai-brain-heading">
                        <h3 id="main-ai-brain-heading">🧠 Main AI Brain</h3>
                        <p>This AI's 'consciousness' metrics are displayed in the OFTCC panel.</p>
                        <div id="nn-visualization-container"></div>
                        <div class="loading-overlay" id="mainBrainLoadingOverlay" aria-live="assertive" aria-busy="true" aria-label="Loading main AI brain">
                            <div class="loading-spinner"></div>
                            <div class="loading-text" id="mainBrainLoadingText">Initializing main AI model...</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="performance-charts-container" role="region" aria-labelledby="performance-heading">
            <h3 id="performance-heading" style="text-align:center; margin-bottom: 20px;">AI Learning & Performance Metrics</h3>
            <div class="charts-grid">
                <div class="chart-container">
                    <h4>Avg. Q-Value (Confidence)</h4>
                    <svg id="qValueChart" class="chart-svg" role="img" aria-label="Average Q-Value over time"></svg>
                </div>
                <div class="chart-container">
                    <h4>Prediction Error (Uncertainty)</h4>
                    <svg id="predErrorChart" class="chart-svg" role="img" aria-label="Prediction Error over time"></svg>
                </div>
                <div class="chart-container">
                    <h4>Epsilon (Exploration Rate)</h4>
                    <svg id="epsilonChart" class="chart-svg" role="img" aria-label="Epsilon exploration rate over time"></svg>
                </div>
                <div class="chart-container">
                    <h4>Score Difference (AI - Opponent)</h4>
                    <svg id="scoreChart" class="chart-svg" role="img" aria-label="Score difference between AI and Opponent over time"></svg>
                </div>
            </div>
        </div>
        <div class="controls-section" role="group" aria-label="Simulation Controls">
             <button id="stepButton" aria-label="Advance simulation by one step (S key)">⏭️ Step</button>
             <button id="pauseButton" aria-label="Pause the simulation (P key)">⏸️ Pause</button>
             <button id="fastForwardButton" aria-label="Toggle fast forward simulation speed (F key)">Fast ⏩</button>
        </div>
        <div class="log-container" role="log" aria-labelledby="system-console-heading">
            <h3 id="system-console-heading">🔧 System Console</h3>
            <div id="log" tabindex="0" aria-live="polite" aria-atomic="true"></div>
        </div>
    </div>
    <script src="https://unpkg.com/@popperjs/core@2"></script>
    <script src="https://unpkg.com/tippy.js@6"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

       <script>
        // This entire block of JavaScript could ideally be split into multiple modules for better maintainability (e.g., utils.js, worker.js, game.js, ai.js, ui.js, main.js).
        // For this example, it remains a single script to facilitate direct modification.

        // --- On-page Logger ---
        const logElement = document.getElementById('log');
        const MAX_LOG_ENTRIES = 200;
        /**
         * Appends a message to the on-page log.
         * @param {string} message - The message to log.
         * @param {'info'|'warn'|'error'} type - The type of log entry.
         */
        function appendLog(message, type = 'info') {
            if (!logElement) {
                console.warn('Log element not found, logging to console:', message);
                return;
            }
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logElement.appendChild(entry);
            if (logElement.children.length > MAX_LOG_ENTRIES) logElement.removeChild(logElement.children[0]);
            logElement.scrollTop = logElement.scrollHeight;
        }
        const logger = {
            info: (msg, data) => appendLog(`INFO: ${msg}` + (data ? ' ' + JSON.stringify(data) : '')),
            warn: (msg, data) => appendLog(`WARN: ${msg}` + (data ? ' ' + JSON.stringify(data) : ''), 'warn'),
            error: (msg, data) => { appendLog(`ERROR: ${msg}` + (data ? ' ' + JSON.stringify(data) : ''), 'error'); console.error(msg, data); }
        };

        // --- Loading Overlay Manager ---
        const loadingOverlays = {
            metrics: document.getElementById('metricsLoadingOverlay'),
            game: document.getElementById('gameLoadingOverlay'),
            mainBrain: document.getElementById('mainBrainLoadingOverlay'),
            opponentBrain: document.getElementById('opponentBrainLoadingOverlay'),
        };
        const loadingTexts = {
            metrics: document.getElementById('metricsLoadingText'),
            game: document.getElementById('gameLoadingText'),
            mainBrain: document.getElementById('mainBrainLoadingText'),
            opponentBrain: document.getElementById('opponentBrainLoadingText'),
        };

        /**
         * Shows a loading overlay on a specific panel.
         * @param {'metrics'|'game'|'mainBrain'|'opponentBrain'} panel - The panel to show the overlay on.
         * @param {string} message - The loading message to display.
         */
        function showLoading(panel, message = 'Processing...') {
            if (loadingOverlays[panel]) {
                loadingOverlays[panel].classList.add('active');
                if (loadingTexts[panel]) loadingTexts[panel].textContent = message;
            }
        }

        /**
         * Hides a loading overlay from a specific panel.
         * @param {'metrics'|'game'|'mainBrain'|'opponentBrain'} panel - The panel to hide the overlay from.
         */
        function hideLoading(panel) {
            if (loadingOverlays[panel]) {
                loadingOverlays[panel].classList.remove('active');
            }
        }

        // --- Web Worker for Heavy Computations ---
        // The worker is defined as a Blob URL to keep it self-contained within the HTML.
        const worker = new Worker(URL.createObjectURL(new Blob([`
            // Worker scope utility functions (must be self-contained or passed)
// --- Worker-specific Utility Functions (self-contained and numerically robust) ---

function clamp(v, min, max) {
    // FIX: Ensure inputs are finite before clamping to prevent NaN propagation
    const safeV = Number.isFinite(v) ? v : 0; // Default to 0 if v is NaN/Infinity
    const safeMin = Number.isFinite(min) ? min : -Infinity; // Ensure min is finite
    const safeMax = Number.isFinite(max) ? max : Infinity; // Ensure max is finite
    return Math.max(safeMin, Math.min(safeMax, safeV));
}

function dot(a, b) {
    if (!a || !b || a.length !== b.length) return 0;
    let s = 0.0;
    for (let i = 0, n = a.length; i < n; ++i) {
        const val_a = a[i];
        const val_b = b[i];
        s += (Number.isFinite(val_a) ? val_a : 0) * (Number.isFinite(val_b) ? val_b : 0);
    }
    return s;
}

function norm2(v) {
    if (!v || v.length === 0) return 0;
    let s = 0;
    for (let i = 0; i < v.length; ++i) {
        const val = v[i];
        s += (Number.isFinite(val) ? val : 0) * (Number.isFinite(val) ? val : 0);
    }
    return Math.sqrt(s + 1e-12); // Add small epsilon for robustness
}

function isFiniteVector(v) {
    if (!v || typeof v.every !== 'function') return false;
    return v.every(x => typeof x === 'number' && Number.isFinite(x));
}

function isFiniteMatrix(m) {
    if (!Array.isArray(m) || m.length === 0) return true; // Empty matrix is finite
    const firstRowLength = m[0]?.length || 0;
    if (m.length > 0 && firstRowLength === 0) return true; // A matrix of empty rows is valid
    return m.every(row => isFiniteVector(row) && row.length === firstRowLength);
}


function matVecMul(m, v) {
    const r = m?.length || 0;
    if (r === 0) return new Float32Array(0);
    const c = m[0]?.length || 0;
    if (!c || !v || v.length !== c) return new Float32Array(r).fill(0);

    const out = new Float32Array(r);
    for (let i = 0; i < r; ++i) {
        let s = 0.0;
        const row = m[i];
        for (let j = 0; j < c; ++j) {
            const val_m = row[j];
            const val_v = v[j];
            const product = (Number.isFinite(val_m) ? val_m : 0) * (Number.isFinite(val_v) ? val_v : 0);
            s += Number.isFinite(product) ? product : 0;
        }
        out[i] = Number.isFinite(s) ? s : 0;
    }
    return out;
}

function unflattenMatrix(data) {
    const { flatData, rows, cols } = data;
    if (!flatData || flatData.length !== rows * cols || !Number.isFinite(rows) || !Number.isFinite(cols) || rows < 0 || cols < 0) {
        return [];
    }
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        const row = new Float32Array(cols);
        for(let j = 0; j < cols; j++) {
            const val = flatData[i * cols + j];
            row[j] = Number.isFinite(val) ? val : 0;
        }
        matrix.push(row);
    }
    return matrix;
}

function flattenMatrix(matrix) {
    if (!isFiniteMatrix(matrix)) {
        return { flatData: new Float32Array(0), rows: 0, cols: 0 };
    }
    const rows = matrix.length;
    const cols = matrix[0]?.length || 0;
    if (rows === 0 || cols === 0) return { flatData: new Float32Array(0), rows: rows, cols: cols };

    const flatData = new Float32Array(rows * cols);
    for (let i = 0; i < rows; i++) {
        for(let j = 0; j < cols; j++) {
            const val = matrix[i][j];
            flatData[i * cols + j] = Number.isFinite(val) ? val : 0;
        }
    }
    return { flatData, rows, cols };
}

function transpose(matrix) {
    if (!isFiniteMatrix(matrix)) {
        return [];
    }
    const numRows = matrix.length;
    const numCols = matrix[0]?.length || 0;
    if (numRows === 0 || numCols === 0) return [];

    const result = Array(numCols).fill(0).map(() => new Float32Array(numRows));
    for (let i = 0; i < numRows; i++) {
        for (let j = 0; j < numCols; j++) {
            const val = matrix[i][j];
            result[j][i] = Number.isFinite(val) ? val : 0;
        }
    }
    return result;
}

function solveLinearSystemCG(A_flat_data, b, opts={tol:1e-6, maxIter:200}) {
    const A = unflattenMatrix(A_flat_data);
    const n = b.length;

    if (!isFiniteMatrix(A) || A.length !== n || (A.length > 0 && A[0].length !== n) || !isFiniteVector(b)) {
        return new Float32Array(b.map(x => Number.isFinite(x) ? clamp(x, -1, 1) : 0)); // Sanitize fallback
    }

    let x = new Float32Array(n).fill(0);
    let r = new Float32Array(b.map(v => Number.isFinite(v) ? v : 0)); // Sanitize r here
    let p = new Float32Array(r);
    let rsold = dot(r, r);

    if (!Number.isFinite(rsold) || rsold < 1e-20) return new Float32Array(x.map(v => Number.isFinite(v) ? clamp(v, -1, 1) : 0)); // Sanitize exit

    const Ap = new Float32Array(n);
    const maxIter = Math.min(opts.maxIter || 200, n * 5);

    for (let it = 0; it < maxIter; ++it) {
        Ap.set(matVecMul(A, p)); // Use robust matVecMul

        const denom = dot(p, Ap);
        if (!Number.isFinite(denom) || denom <= 1e-20) {
            break;
        }

        const alpha = rsold / denom;
        if (!Number.isFinite(alpha)) {
            break; // Break if alpha is NaN/Infinity
        }

        for (let i = 0; i < n; i++) x[i] = (Number.isFinite(x[i]) ? x[i] : 0) + (Number.isFinite(alpha) ? alpha : 0) * (Number.isFinite(p[i]) ? p[i] : 0);
        for (let i = 0; i < n; i++) r[i] = (Number.isFinite(r[i]) ? r[i] : 0) - (Number.isFinite(alpha) ? alpha : 0) * (Number.isFinite(Ap[i]) ? Ap[i] : 0);

        const rsnew = dot(r, r);
        if (!Number.isFinite(rsnew)) {
            break;
        }
        if (Math.sqrt(rsnew) < (opts.tol || 1e-6)) break;

        const beta = rsnew / (rsold + 1e-20);
        if (!Number.isFinite(beta)) {
            break; // Break if beta is NaN/Infinity
        }

        for (let i = 0; i < n; i++) p[i] = (Number.isFinite(r[i]) ? r[i] : 0) + (Number.isFinite(beta) ? beta : 0) * (Number.isFinite(p[i]) ? p[i] : 0);
        rsold = rsnew;
    }
    return new Float32Array(x.map(v => Number.isFinite(v) ? clamp(v, -1, 1) : 0)); // Final sanitization of x
}

function covarianceMatrix(states_array, eps = 1e-3) {
    const states = states_array.filter(s => isFiniteVector(s));
    if (!Array.isArray(states) || states.length < 2) { // Need at least 2 states for covariance
        return [[eps]]; // Return a minimal valid covariance
    }
    
    const n = states.length;
    const d = states[0]?.length || 0;
    if (d === 0) {
        return [[eps]];
    }

    const mean = new Float32Array(d).fill(0);
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < d; j++) {
            const val = states[i][j];
            mean[j] += Number.isFinite(val) ? val : 0;
        }
    }
    for (let j = 0; j < d; j++) mean[j] /= n;

    const cov = Array(d).fill(0).map(() => new Float32Array(d).fill(0));
    for (let k = 0; k < n; k++) {
        for (let i = 0; i < d; i++) {
            const di = (Number.isFinite(states[k][i]) ? states[k][i] : 0) - (Number.isFinite(mean[i]) ? mean[i] : 0);
            for (let j = i; j < d; j++) {
                const dj = (Number.isFinite(states[k][j]) ? states[k][j] : 0) - (Number.isFinite(mean[j]) ? mean[j] : 0);
                const product = di * dj;
                cov[i][j] += (Number.isFinite(product) ? product : 0) / Math.max(1, n - 1);
            }
        }
    }
    for (let i = 0; i < d; i++) {
        for (let j = 0; j < i; j++) cov[j][i] = cov[i][j];
    }
    for (let i = 0; i < d; i++) cov[i][i] = (Number.isFinite(cov[i][i]) ? cov[i][i] : 0) + eps; // Add regularization
    
    // Final check for the output covariance matrix to ensure it's finite
    for (let i = 0; i < d; i++) {
        for (let j = 0; j < d; j++) {
            if (!Number.isFinite(cov[i][j])) {
                cov[i][j] = 0; // Replace non-finite with 0
            }
        }
    }

    return cov;
}

function matrixSpectralNormApprox(M_flat_data, maxIter = 10) {
    const M = unflattenMatrix(M_flat_data);
    if (!isFiniteMatrix(M)) {
        return 0;
    }
    let n = M.length;
    if (n === 0) return 0;
    
    let v = new Float32Array(n).fill(1 / Math.sqrt(n)); // Initial vector

    for (let i = 0; i < maxIter; i++) {
        const Av = matVecMul(M, v);
        if (!isFiniteVector(Av)) {
            return 0;
        }
        const norm = norm2(Av);
        if (norm < 1e-10) return 0; // If norm is zero, spectral norm is zero
        for(let k=0; k<n; k++) v[k] = (Av[k] || 0) / norm; // Normalize v
    }
    const finalAv = matVecMul(M, v);
    if (!isFiniteVector(finalAv)) {
        return 0;
    }
    return norm2(finalAv);
}

function matrixRank(M_flat_data) {
    const M = unflattenMatrix(M_flat_data);
    if (!isFiniteMatrix(M)) {
        return 0;
    }
    const m = M.length;
    if (m === 0) return 0;
    const n = M[0]?.length || 0;
    if (n === 0) return 0;

    const A = M.map(row => new Float32Array(row)); // Create a copy
    let rank = 0;
    const tol = 1e-10;

    for (let col = 0; col < n && rank < m; col++) {
        let pivotRow = rank;
        for (let i = rank + 1; i < m; i++) {
            if (Math.abs(A[i][col]) > Math.abs(A[pivotRow][col])) pivotRow = i;
        }

        if (Math.abs(A[pivotRow][col]) < tol) continue; // Column is effectively zero

        // Swap pivot row
        [A[rank], A[pivotRow]] = [A[pivotRow], A[rank]];

        const pivot = A[rank][col];
        if (!Number.isFinite(pivot) || Math.abs(pivot) < tol) {
             continue;
        }
        // Normalize pivot row
        for (let j = col; j < n; j++) A[rank][j] = (A[rank][j] || 0) / pivot;

        // Eliminate other rows
        for (let i = 0; i < m; i++) {
            if (i === rank) continue;
            const factor = A[i][col];
            if (!Number.isFinite(factor)) {
                continue;
            }
            for (let j = col; j < n; j++) A[i][j] = (A[i][j] || 0) - (factor * (A[rank][j] || 0));
        }
        rank++;
    }
    return rank;
}

// --- Worker Message Handler ---
self.onmessage = function(e) {
    const { type, id, data } = e.data;
    let result;
    try {
        switch (type) {
            case 'transpose':
                const matrixToTranspose = unflattenMatrix(data.matrix); 
                const transposedMatrix = transpose(matrixToTranspose);
                result = flattenMatrix(transposedMatrix);
                break;
            case 'matVecMul':
                const matrixForMatVecMul = unflattenMatrix(data.matrix);
                result = matVecMul(matrixForMatVecMul, data.vector);
                break;
            case 'solveLinearSystemCG':
                result = solveLinearSystemCG(data.A, data.b, data.opts);
                break;
            case 'covarianceMatrix':
                result = covarianceMatrix(data.states, data.eps);
                break;
            case 'matrixSpectralNormApprox':
                result = matrixSpectralNormApprox(data.matrix);
                break;
            case 'matrixRank':
                result = matrixRank(data.matrix);
                break;
            default:
                result = { error: 'Unknown message type' };
                break;
        }
        self.postMessage({ type: type + 'Result', id, result });
    } catch (error) {
        console.error('Worker error for type ' + type + ':', error);
        self.postMessage({ type: type + 'Error', id, error: error.message });
    }
};
        `], { type: 'application/javascript' })));

        // --- Asynchronous Worker Task Manager ---
        const workerCallbacks = new Map();
        let nextWorkerTaskId = 0;

        /**
         * Runs a task in the web worker and returns a Promise.
         * @param {string} type - The type of task for the worker.
         * @param {Object} data - The data to send to the worker.
         * @param {number} timeout - Maximum time in ms to wait for the worker task.
         * @returns {Promise<any>} A promise that resolves with the worker's result or rejects on error/timeout.
         */
        function runWorkerTask(type, data, timeout = 10000) { // Default timeout increased to 10 seconds for initial heavy ops
            return new Promise((resolve, reject) => {
                const id = nextWorkerTaskId++;
                const timer = setTimeout(() => {
                    workerCallbacks.delete(id);
                    logger.error(`Worker task '${type}' (id: ${id}) timed out after ${timeout}ms. Rejecting.`);
                    reject(new Error(`Worker task '${type}' (id: ${id}) timed out after ${timeout}ms.`));
                }, timeout);
                workerCallbacks.set(id, {
                    resolve: (result) => { clearTimeout(timer); resolve(result); },
                    reject: (error) => { clearTimeout(timer); reject(error); },
                });
                worker.postMessage({ type, id, data });
            });
        }
        worker.onmessage = function(e) {
            const { id, result, error } = e.data;
            const callback = workerCallbacks.get(id);
            if (callback) {
                if (error) {
                    logger.error(`Worker task ${e.data.type.replace('Result', '')} (id: ${id}) error: ${error}`);
                    callback.reject(error);
                }
                else callback.resolve(result);
                workerCallbacks.delete(id);
            }
        };
        worker.onerror = function(error) {
            logger.error('Worker global error:', error.message || error.toString()); // More robust error logging
            workerCallbacks.forEach(cb => cb.reject(new Error('Worker crashed')));
            workerCallbacks.clear();
        };
// --- CORE UTILITY FUNCTIONS (used by main thread classes) ---
// These functions are essential for vector and matrix operations within the main thread.
// Their logic is consistent with the worker's for numerical robustness.
function clamp(v, min, max) { 
    // FIX: Ensure inputs are finite before clamping to prevent NaN propagation
    const safeV = Number.isFinite(v) ? v : 0; // Default to 0 if v is NaN/Infinity
    const safeMin = Number.isFinite(min) ? min : -Infinity; // Ensure min is finite
    const safeMax = Number.isFinite(max) ? max : Infinity; // Ensure max is finite
    return Math.max(safeMin, Math.min(safeMax, safeV));
}
function dot(a, b) {
    if (!a || !b || a.length !== b.length) return 0;
    let s = 0.0;
    for (let i = 0, n = a.length; i < n; ++i) {
        const ai = a[i], bi = b[i];
        if (!Number.isFinite(ai) || !Number.isFinite(bi)) return 0; // Ensure finite values
        s += ai * bi;
    }
    return s;
}
function norm2(v) {
    if (!Array.isArray(v) && !(v instanceof Float32Array)) return 0;
    let s = 0;
    for (let i = 0; i < v.length; ++i) {
        const val = v[i];
        s += (Number.isFinite(val) ? val : 0) * (Number.isFinite(val) ? val : 0);
    }
    return Math.sqrt(s + 1e-12); // Add small epsilon for robustness
}
function vecAdd(a, b) {
    const n = Math.max(a?.length||0, b?.length||0);
    const out = new Float32Array(n);
    for (let i = 0; i < n; ++i) out[i] = (Number.isFinite(a[i]) ? a[i] : 0) + (Number.isFinite(b[i]) ? b[i] : 0);
    return out;
}
function vecSub(a, b) {
    const n = Math.max(a?.length||0, b?.length||0);
    const out = new Float32Array(n);
    for (let i = 0; i < n; ++i) out[i] = (Number.isFinite(a[i]) ? a[i] : 0) - (Number.isFinite(b[i]) ? b[i] : 0);
    return out;
}
function vecScale(v, s) {
    const n = v?.length || 0;
    const out = new Float32Array(n);
    for (let i = 0; i < n; ++i) out[i] = (Number.isFinite(v[i]) ? v[i] : 0) * (Number.isFinite(s) ? s : 0);
    return out;
}
function tanhVec(v) {
    if (!isFiniteVector(v)) { logger.warn('tanhVec: Input vector is not finite. Returning zeros.'); return vecZeros(v?.length || 0); }
    return new Float32Array(v.map(x => Math.tanh(x)));
}
// NEW: Sigmoid function for LSTM-like gates
function sigmoidVec(v) {
    if (!isFiniteVector(v)) { logger.warn('sigmoidVec: Input vector is not finite. Returning zeros.'); return vecZeros(v?.length || 0); }
    return new Float32Array(v.map(x => 1 / (1 + Math.exp(-x))));
}
// NEW: Element-wise vector multiplication
function vecMul(a, b) {
    const n = Math.max(a?.length||0, b?.length||0);
    const out = new Float32Array(n);
    for (let i = 0; i < n; ++i) out[i] = (Number.isFinite(a[i]) ? a[i] : 0) * (Number.isFinite(b[i]) ? b[i] : 0);
    return out;
}
function randomMatrix(r, c, scale) {
    return Array(r).fill().map(() => new Float32Array(c).fill().map(() => clamp((Math.random() - 0.5) * scale, -1, 1))); // Clamp random values
}
function vecZeros(n) { return new Float32Array(n).fill(0); }
function zeroMatrix(r, c) { return Array(r).fill().map(() => new Float32Array(c).fill(0)); }
function identity(n) {
    const M = zeroMatrix(n, n);
    for (let i = 0; i < n; i++) M[i][i] = 1;
    return M;
}
/**
 * Checks if all elements in a vector are finite numbers.
 * @param {Float32Array | number[]} v - The vector to check.
 * @returns {boolean} True if all elements are finite, false otherwise.
 */
function isFiniteVector(v) {
    if (!Array.isArray(v) && !(v instanceof Float32Array)) return false;
    return v.every(x => typeof x === 'number' && Number.isFinite(x));
}
/**
 * Checks if all elements in a matrix are finite numbers.
 * @param {Float32Array[] | number[][]} m - The matrix to check.
 * @returns {boolean} True if all elements are finite, false otherwise.
 */
function isFiniteMatrix(m) {
    if (!Array.isArray(m) || m.length === 0) return true;
    const firstRowLength = m[0]?.length ?? 0;
    return m.every(row => (Array.isArray(row) || row instanceof Float32Array) && row.length === firstRowLength && isFiniteVector(row));
}
function flattenMatrix(matrix) {
    if (!isFiniteMatrix(matrix)) { logger.warn('flattenMatrix: Input matrix is not finite. Returning empty.'); return { flatData: new Float32Array(0), rows: 0, cols: 0 }; }
    const rows = matrix.length;
    const cols = matrix[0]?.length || 0;
    if (rows === 0 || cols === 0) return { flatData: new Float32Array(0), rows, cols };
    const flatData = new Float32Array(rows * cols);
    for (let i = 0; i < rows; i++) for(let j = 0; j < cols; j++) flatData[i * cols + j] = matrix[i][j];
    return { flatData, rows, cols };
}
function unflattenMatrix(data) { // This version is only used in main thread for deserialization when needed
    const { flatData, rows, cols } = data;
    if (!flatData || flatData.length !== rows * cols) return [];
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        const row = new Float32Array(cols);
        for (let j = 0; j < cols; j++) {
            row[j] = flatData[i * cols + j];
        }
        matrix.push(row);
    }
    return matrix;
}
function logDeterminantFromDiagonal(M) {
    if (!Array.isArray(M) || M.length === 0) return Math.log(1e-12); // Return log(epsilon) for empty
    let s = 0;
    for (let i=0;i<M.length;i++) {
        const val = M[i]?.[i];
        if (!Number.isFinite(val)) { logger.warn('logDeterminantFromDiagonal: Non-finite diagonal element. Skipping.'); continue; }
        s += Math.log(Math.max(Math.abs(val), 1e-12)); // Use Math.abs and small epsilon
    }
    return s;
}

const sheafVertexPositions = {
    0: {x:0.1, y:0.5}, 1: {x:0.3, y:0.2}, 2: {x:0.3, y:0.8},
    3: {x:0.9, y:0.5}, 4: {x:0.7, y:0.2}, 5: {x:0.7, y:0.8},
    6: {x:0.5, y:0.35}, 7: {x:0.5, y:0.65}
};

// --- APPLICATION CLASSES ---

/**
 * Represents an Enhanced Qualia Sheaf, a mathematical structure used to model the AI's "consciousness".
 * It handles qualia diffusion, topological adaptation, and metric computations like Phi, H1 dimension, etc.
 */
class EnhancedQualiaSheaf {
    /**
     * @param {Object} graph - Initial graph structure with vertices and edges.
     * @param {number} stateDim - Dimension of the input state vector.
     * @param {number} initialQDim - Initial dimension for qualia vectors (should be 7).
     * @param {number} alpha - Parameter controlling sensory input influence.
     * @param {number} beta - Parameter controlling diffusion strength.
     * @param {number} gamma - Parameter controlling qualia update inertia/learning rate.
     */
    constructor(graph, stateDim = 8, initialQDim = 7, alpha = 0.1, beta = 0.1, gamma = 0.05) {
        this.stateDim = stateDim;
        this.entityNames = ['being', 'intent', 'existence', 'emergence', 'gestalt', 'context', 'rel_emergence'];
        this.qDim = this.entityNames.length; // This should always be 7
        
        // UPDATED for 3D Game
        const defaultVertices = ['agent_x', 'agent_z', 'agent_rot', 'target_x', 'target_z', 'vec_dx', 'vec_dz', 'dist_target'];

        const initialGraphVertices = graph?.vertices && Array.isArray(graph.vertices) && graph.vertices.length >= defaultVertices.length ? graph.vertices : defaultVertices;

        const initialBaseEdges = graph?.edges && Array.isArray(graph.edges) ? graph.edges.slice(0, 15) : [
            ['agent_x', 'agent_rot'], ['agent_z', 'agent_rot'],
            ['agent_x', 'vec_dx'], ['agent_z', 'vec_dz'],
            ['target_x', 'vec_dx'], ['target_z', 'vec_dz'],
            ['vec_dx', 'dist_target'], ['vec_dz', 'dist_target']
        ];
        
        // UPDATED for 3D Game
        const explicitTriangles = [
             ['agent_x', 'agent_z', 'agent_rot'],
             ['target_x', 'target_z', 'dist_target'],
             ['agent_x', 'target_x', 'vec_dx'],
             ['agent_z', 'target_z', 'vec_dz']
        ];

        // If 'graph' object includes triangles, prioritize those
        const finalTriangles = graph?.triangles && Array.isArray(graph.triangles) ? graph.triangles : explicitTriangles;


        // --- Step 1: Collect all unique vertices from initialGraphVertices and explicitTriangles ---
        const allVerticesSet = new Set(initialGraphVertices);
        finalTriangles.forEach(triangle => {
            triangle.forEach(v => allVerticesSet.add(v));
        });
        const finalVertices = Array.from(allVerticesSet);

        // --- Step 2: Collect all unique edges from initialBaseEdges and edges implied by finalTriangles ---
        const allEdgesSet = new Set();
        initialBaseEdges.forEach(edge => {
            allEdgesSet.add(edge.slice().sort().join(',')); // Add explicitly defined base edges
        });

        finalTriangles.forEach(triangle => {
            const [v1, v2, v3] = triangle;
            const edgesOfTriangle = [[v1, v2], [v2, v3], [v3, v1]];
            edgesOfTriangle.forEach(edge => {
                allEdgesSet.add(edge.slice().sort().join(',')); // Add edges implied by triangles
            });
        });
        const finalEdges = Array.from(allEdgesSet).map(s => s.split(','));

        // --- Step 3: Assign to this.graph and this.simplicialComplex ---
        this.graph = {
            vertices: finalVertices,
            edges: finalEdges
        };
        this.simplicialComplex = {
            vertices: finalVertices,
            edges: finalEdges,
            triangles: finalTriangles
        };

        this.alpha = clamp(alpha, 0.01, 1);
        this.beta = clamp(beta, 0.01, 1);
        this.gamma = clamp(gamma, 0.01, 0.5);
        this.eps = 1e-6; // Epsilon for numerical stability

        this.stalks = new Map(this.graph.vertices.map(v =>
            [v, new Float32Array(this.qDim).fill(0).map(() => clamp((Math.random() - 0.5) * 0.5, -1, 1))]
        ));

        // NEW: For adaptive topology
        this.correlationMatrix = zeroMatrix(this.graph.vertices.length, this.graph.vertices.length);
        this.stalkHistory = [];
        this.stalkHistorySize = 100;

        this.adjacencyMatrix = null;
        this.laplacian = null;
        this.maxEigApprox = 1;
        this.projectionMatrices = new Map();
        this.ready = false;

        this.phi = 0.2;
        this.h1Dimension = 0;
        this.gestaltUnity = 0.6;
        this.stability = 0.6;
        this.diffusionEnergy = 0;
        this.inconsistency = 0;
        this.windowedStates = [];
        const N_total_stalk_dim = this.graph.vertices.length * this.qDim;
        this.windowSize = Math.max(50, N_total_stalk_dim * 2); // Ensure window is large enough relative to state dim
        for (let i = 0; i < this.windowSize; i++) {
            this.windowedStates.push(new Float32Array(N_total_stalk_dim).fill(0).map(() => clamp((Math.random() - 0.5) * 0.1, -1, 1)));
        }
        logger.info(`EnhancedQualiaSheaf initialized: qDim=${this.qDim}, vertices=${this.graph.vertices.length}`);
    }

    /**
     * Initializes the sheaf by updating its graph structure and derived metrics.
     * @returns {Promise<void>}
     */
    async initialize() {
        logger.info('EnhancedQualiaSheaf.initialize() called.');
        try {
            await this._updateGraphStructureAndMetrics();
            await this._updateDerivedMetrics(); // Ensure metrics are calculated initially
            this.ready = true;
            logger.info('EnhancedQualiaSheaf ready.');
        } catch (e) {
            logger.error('Error during Sheaf initialization:', e);
            this.ready = false;
            throw e; // Re-throw to propagate to MainApp
        }
    }

    /**
     * Adapts the sheaf topology by calculating functional connectivity based on stalk activity correlation.
     */
    adaptSheafTopology() {
        if (this.stalkHistory.length < this.stalkHistorySize) return;

        const numVertices = this.graph.vertices.length;
        if (numVertices === 0) return;

        const means = new Float32Array(numVertices).fill(0);

        // Calculate means for each vertex's stalk norm over history
        for (let i = 0; i < numVertices; i++) {
            for (let t = 0; t < this.stalkHistorySize; t++) {
                means[i] += this.stalkHistory[t][i];
            }
            means[i] /= this.stalkHistorySize;
        }

        // Calculate Pearson correlation
        for (let i = 0; i < numVertices; i++) {
            for (let j = i; j < numVertices; j++) {
                let numerator = 0;
                let denom_i = 0;
                let denom_j = 0;
                for (let t = 0; t < this.stalkHistorySize; t++) {
                    const diff_i = (this.stalkHistory[t][i] || 0) - (means[i] || 0);
                    const diff_j = (this.stalkHistory[t][j] || 0) - (means[j] || 0);
                    numerator += diff_i * diff_j;
                    denom_i += diff_i * diff_i;
                    denom_j += diff_j * diff_j;
                }
                const correlation = (Math.sqrt(denom_i) * Math.sqrt(denom_j)) < 1e-9 ? 0 : numerator / (Math.sqrt(denom_i) * Math.sqrt(denom_j));
                const finalCorr = clamp(correlation, -1, 1);
                this.correlationMatrix[i][j] = finalCorr;
                this.correlationMatrix[j][i] = finalCorr;
            }
        }
    }

    /**
     * Builds the boundary matrices (d1 and d2) for homological computations.
     * @returns {{boundary1: Float32Array[][], boundary2: Float32Array[][]}}
     */
    buildBoundaryMatrices() {
        const vIdx = new Map(this.graph.vertices.map((v, i) => [v, i]));
        const edgeKeys = this.graph.edges.map(e => e.slice().sort().join(','));
        const eIdx = new Map(edgeKeys.map((e, i) => [e, i]));
        const nV = this.graph.vertices.length;
        const nE = this.graph.edges.length;
        const nT = this.simplicialComplex.triangles.length;

        const boundary1 = zeroMatrix(nE, nV);
        this.graph.edges.forEach(([u, v], i) => {
            boundary1[i][vIdx.get(u)] = -1;
            boundary1[i][vIdx.get(v)] = 1;
        });

        const boundary2 = zeroMatrix(nT, nE);
        this.simplicialComplex.triangles.forEach(([u, v, w], i) => {
            const edges = [[u, v], [v, w], [w, u]];
            edges.forEach(([a, b]) => {
                const sortedEdge = [a, b].sort().join(',');
                const eIndex = eIdx.get(sortedEdge);
                if (eIndex !== undefined) {
                    const sign = (a === [a,b].sort()[0]) ? 1 : -1;
                    boundary2[i][eIndex] = sign;
                }
            });
        });
        return { boundary1, boundary2 };
    }

    /**
     * Builds the adjacency matrix, incorporating both structural and functional (correlation-based) weights.
     * @returns {Float32Array[][]} The adjacency matrix.
     */
    buildAdjacencyMatrix() {
        const n = this.graph.vertices.length;
        const mapIdx = new Map(this.graph.vertices.map((v, i) => [v, i]));
        const adj = zeroMatrix(n, n);
        
        for (const [u, v] of this.graph.edges) {
            const i = mapIdx.get(u), j = mapIdx.get(v);
            if (i === undefined || j === undefined) continue;

            // Start with a base weight of 1 for existing structural edges
            let baseWeight = 1.0; 

            // Modulate by correlation (if available). Positive correlation strengthens, negative weakens.
            const correlation = this.correlationMatrix[i][j] || 0;
            // The mapping (1 + correlation) / 2 scales [-1, 1] to [0, 1]
            const correlationFactor = (1 + correlation) / 2;

            // Combine base structure with learned functional correlation
            // Ensure a minimum non-zero weight for connectivity, scaled by correlation factor
            const finalWeight = baseWeight * (0.1 + 0.9 * correlationFactor); // Minimum 0.1 weight
            
            adj[i][j] = clamp(finalWeight, 0.01, 1.0); // Ensure a minimum connectivity
            adj[j][i] = clamp(finalWeight, 0.01, 1.0);
        }
        return adj;
    }

    /**
     * Computes the local clustering coefficients for each vertex in the graph.
     * (Currently not directly used for system metrics, but useful for graph analysis).
     * @returns {Float32Array} Array of clustering coefficients.
     */
    computeClustering() {
        const n = this.graph.vertices.length;
        const adjBinary = zeroMatrix(n, n);
        const mapIdx = new Map(this.graph.vertices.map((v, i) => [v, i]));
        for (const [u, v] of this.graph.edges) {
            const i = mapIdx.get(u), j = mapIdx.get(v);
            if (i !== undefined && j !== undefined) {
                adjBinary[i][j] = 1;
                adjBinary[j][i] = 1;
            }
        }

        const clustering = new Float32Array(n).fill(0);
        for (let i = 0; i < n; i++) {
            const neighbors = [];
            for (let j = 0; j < n; j++) if (adjBinary[i][j]) neighbors.push(j);
            const k = neighbors.length;
            if (k < 2) continue;
            let tri = 0;
            for (let a = 0; a < neighbors.length; a++) {
                for (let b = a + 1; b < neighbors.length; b++) {
                    if (adjBinary[neighbors[a]][neighbors[b]]) tri++;
                }
            }
            const possible = k * (k - 1) / 2;
            clustering[i] = possible > 0 ? tri / possible : 0;
        }
        return clustering;
    }

    /**
     * Builds the graph Laplacian matrix based on the current adjacency matrix.
     * @returns {Float32Array[][]} The Laplacian matrix.
     */
    buildLaplacian() {
        const n = this.graph.vertices.length;
        const adj = this.adjacencyMatrix || this.buildAdjacencyMatrix();
        const L = zeroMatrix(n, n);

        for (let i = 0; i < n; i++) {
            let deg = 0;
            for (let j = 0; j < n; j++) {
                if (adj[i][j] > 0) {
                    L[i][j] = -adj[i][j];
                    deg += adj[i][j];
                }
            }
            L[i][i] = deg + this.eps; // Add self-loop for robustness
        }
        return L;
    }

    /**
     * Computes projection matrices for each edge in the graph.
     * Currently, these are identity matrices, implying direct projection (no transformation) of qualia.
     * @returns {Promise<Map<string, Float32Array[][]>>} A map of projection matrices.
     */
    async computeProjectionMatrices() {
        const projections = new Map();
        const identityMatrix = identity(this.qDim); // The stable identity matrix (no worker needed for this)

        for (const [u, v] of this.graph.edges) {
            const P_uv = identityMatrix;
            const P_vu = identityMatrix; // Transpose of identity is itself.

            projections.set(`${u}-${v}`, P_uv);
            projections.set(`${v}-${u}`, P_vu);
        }
        return projections;
    }

    /**
     * Updates the graph structure, adjacency matrix, Laplacian, and spectral norm.
     * This is a critical step before qualia diffusion.
     * @private
     * @returns {Promise<void>}
     */
    async _updateGraphStructureAndMetrics() {
        try {
            this.adaptSheafTopology(); // Adapt topology before rebuilding matrices
            this.adjacencyMatrix = this.buildAdjacencyMatrix();
            this.laplacian = this.buildLaplacian();
            this.maxEigApprox = await runWorkerTask('matrixSpectralNormApprox', { matrix: flattenMatrix(this.laplacian) }, 10000) || 1; // 10s timeout
            this.projectionMatrices = await this.computeProjectionMatrices();
            if (!Number.isFinite(this.maxEigApprox) || this.maxEigApprox <= 0) {
                logger.warn(`maxEigApprox was invalid (${this.maxEigApprox}). Resetting to 1.`);
                this.maxEigApprox = 1; // Fallback
            }
        } catch (e) {
            logger.error("Failed to update graph structure and metrics", e);
            throw e; // Propagate error for loading overlay to catch
        }
    }

    /**
     * Diffuses qualia across the sheaf based on the current state input.
     * This involves solving a linear system.
     * @param {Float32Array} state - The current input state vector.
     * @returns {Promise<void>}
     */
    async diffuseQualia(state) {
        if (!this.ready) {
            logger.warn('Sheaf not ready for diffusion. Skipping.');
            return;
        }
        if (!isFiniteVector(state) || state.length !== this.stateDim) {
            logger.warn('diffuseQualia: Invalid input state received. Skipping diffusion.', state);
            return;
        }

        await this._updateGraphStructureAndMetrics(); 

        const qInput = new Float32Array(state.slice(0, this.graph.vertices.length).map(v => clamp(v, 0, 1)));
        if (!isFiniteVector(qInput) || qInput.length !== this.graph.vertices.length) {
            logger.warn('diffuseQualia: Invalid qInput generated. Skipping diffusion.', qInput);
            return;
        }

        const n = this.graph.vertices.length;
        const N = n * this.qDim;

        const s = new Float32Array(N);
        let currentOffset = 0;
        for (const vertexName of this.graph.vertices) {
            let stalkValue = this.stalks.get(vertexName);
            if (!stalkValue || !isFiniteVector(stalkValue) || stalkValue.length !== this.qDim) {
                logger.warn(`Found invalid or missing stalk for vertex ${vertexName}. Resetting to zeros.`);
                stalkValue = vecZeros(this.qDim);
                this.stalks.set(vertexName, stalkValue); // Update the map with a clean vector
            }
            s.set(stalkValue.map(v => Number.isFinite(v) ? v : 0), currentOffset); // Ensure elements are finite on copy
            currentOffset += this.qDim;
        }

        // After assembling 's', make sure it's fully finite before proceeding
        if (!isFiniteVector(s)) {
            logger.error('diffuseQualia: Initial concatenated stalk vector "s" contains non-finite values. Resetting to zeros for current diffusion step.', s);
            s.fill(0); // Reset 's' to zeros to avoid feeding NaNs to the solver
        }

        const Lnode = this.laplacian;
        // --- FIX: Correctly construct the Sheaf Laplacian (Lfull) ---
        const Lfull = zeroMatrix(N, N);
        const idx = new Map(this.graph.vertices.map((v, i) => [v, i]));

        // 1. Build the off-diagonal blocks
        for (const [u, v] of this.graph.edges) {
            const i = idx.get(u), j = idx.get(v);
            if (i === undefined || j === undefined) continue;

            const weight = this.adjacencyMatrix[i][j];
            if (!Number.isFinite(weight) || weight <= 0) continue;

            const P_uv = this.projectionMatrices.get(`${u}-${v}`);
            const P_vu = this.projectionMatrices.get(`${v}-${u}`);

            if (!isFiniteMatrix(P_uv) || !isFiniteMatrix(P_vu)) {
                logger.warn(`Non-finite projection matrix for edge ${u}-${v}. Skipping block.`);
                continue;
            }

            // Off-diagonal block (i, j) is -W_ij * P_uv
            for (let qi = 0; qi < this.qDim; qi++) {
                for (let qj = 0; qj < this.qDim; qj++) {
                    const val_uv = -weight * (P_uv[qi]?.[qj] || 0);
                    if (Number.isFinite(val_uv)) {
                        Lfull[i * this.qDim + qi][j * this.qDim + qj] = val_uv;
                    } else {
                        Lfull[i * this.qDim + qi][j * this.qDim + qj] = 0;
                    }
                }
            }
            // Off-diagonal block (j, i) is -W_ji * P_vu
            for (let qi = 0; qi < this.qDim; qi++) {
                for (let qj = 0; qj < this.qDim; qj++) {
                     const val_vu = -weight * (P_vu[qi]?.[qj] || 0); // weight is symmetric
                     if (Number.isFinite(val_vu)) {
                        Lfull[j * this.qDim + qi][i * this.qDim + qj] = val_vu;
                     } else {
                         Lfull[j * this.qDim + qi][i * this.qDim + qj] = 0;
                     }
                }
            }
        }

        // 2. Build the diagonal blocks
        for (let i = 0; i < n; i++) {
            let degree = 0;
            // Sum of weights of edges incident to vertex i
            for (let j = 0; j < n; j++) {
                if (i !== j) { // Don't include self-loop degree here, it's added explicitly
                    degree += (this.adjacencyMatrix[i]?.[j] || 0);
                }
            }
            // The diagonal block (i, i) is degree_i * Identity - Sum_{k!=i} W_ik * P_ik
            // Since P_ik = Identity, the second term is just Sum_{k!=i} W_ik * Identity
            // So, Diag(L_ii) = (degree_i + eps) * Identity
            for (let qi = 0; qi < this.qDim; qi++) {
                Lfull[i * this.qDim + qi][i * this.qDim + qi] = (Number.isFinite(degree) ? degree : 0) + this.eps;
            }
        }

        const f_s = new Float32Array(N).fill(0);
        for (let i = 0; i < n; i++) {
            const inputVal = qInput[i % qInput.length];
            for (let qi = 0; qi < this.qDim; qi++) {
                f_s[i * this.qDim + qi] = this.alpha * inputVal * 0.7; // Sensory input
            }
        }

        const eta = this.gamma / Math.max(1, this.maxEigApprox); // Time step / effective learning rate
        
        // Ensure A is constructed robustly
        const A = identity(N).map((row, i) => new Float32Array(row.map((v, j) => {
            const val = v + eta * (Lfull[i]?.[j] || 0);
            return Number.isFinite(val) ? val : 0; // Sanitize A elements
        })));
        
        const rhs = vecAdd(s, vecScale(f_s, eta)).map(v => Number.isFinite(v) ? clamp(v, -10, 10) : 0); // Explicitly sanitize rhs

        if (!isFiniteMatrix(A) || !isFiniteVector(rhs)) {
            logger.error('diffuseQualia: Matrix A or RHS vector contains non-finite values before CG solve. Skipping diffusion or using fallback.');
            const sNext = new Float32Array(N).fill(0); 
            this._updateStalksAndWindow(sNext, n);
            await this._updateDerivedMetrics();
            return;
        }

        let sSolved;
        try {
            sSolved = await runWorkerTask('solveLinearSystemCG', { A: flattenMatrix(A), b: rhs, opts: { tol: 1e-6, maxIter: 15 } }, 5000); // 5s timeout
        } catch (e) {
            logger.error('Error solving linear system in worker (CG). Falling back to zero vector:', e);
            sSolved = new Float32Array(N).fill(0); // Fallback to a clean zero vector on worker error
        }

        // --- Stronger Circuit Breaker ---
        if (!isFiniteVector(sSolved)) {
            logger.error('CRITICAL: Solver output or fallback contained non-finite values. Resetting sSolved to zero vector.', { sSolved });
            sSolved = new Float32Array(N).fill(0); 
        }
        
        const sNext = new Float32Array(sSolved.map(v => Number.isFinite(v) ? clamp(v, -1, 1) : 0));

        this._updateStalksAndWindow(sNext, n);
        await this._updateDerivedMetrics();
    }

    /**
     * Updates the internal stalk values and maintains a history window for correlation analysis.
     * @param {Float32Array} sNextVector - The newly diffused qualia vector.
     * @param {number} n - Number of vertices.
     * @private
     */
    _updateStalksAndWindow(sNextVector, n) {
        // Update stalk history for correlation analysis
        const currentStalkNorms = new Float32Array(n);
        for (let i = 0; i < n; i++) {
            // Ensure each stalk is fully finite before setting
            const rawStalkSlice = sNextVector.slice(i * this.qDim, (i + 1) * this.qDim);
            const sanitizedStalk = new Float32Array(rawStalkSlice.map(v => Number.isFinite(v) ? clamp(v, -1, 1) : 0));
            this.stalks.set(this.graph.vertices[i], sanitizedStalk);
            currentStalkNorms[i] = norm2(sanitizedStalk); // Use sanitized stalk for norm
        }
        this.stalkHistory.push(currentStalkNorms);
        if (this.stalkHistory.length > this.stalkHistorySize) {
            this.stalkHistory.shift();
        }

        const sanitizedNextVector = new Float32Array(sNextVector.map(v => Number.isFinite(v) ? clamp(v, -1, 1) : 0));
        // Also ensure the windowedStates are always finite
        this.windowedStates.push(sanitizedNextVector);
        if (this.windowedStates.length > this.windowSize) this.windowedStates.shift();
    }

    /**
     * Updates all derived consciousness metrics (H1, inconsistency, Gestalt unity, Phi).
     * @private
     * @returns {Promise<void>}
     */
    async _updateDerivedMetrics() {
        try {
            await this.computeH1Dimension();
            await this.computeGluingInconsistency();
            this.computeGestaltUnity(); // Not async
            await this.computeIntegratedInformation();
        } catch (e) {
            logger.error("Error during derived metrics update:", e);
            // Fallback values in case of error
            this.phi = 0.01;
            this.h1Dimension = 0.5;
            this.gestaltUnity = 0.05;
            this.stability = 0.01;
            this.inconsistency = 1.0;
        }
    }

    /**
     * Computes the dimension of the first cohomology group (H1), indicating structural complexity.
     * @returns {Promise<void>}
     */
    async computeH1Dimension() {
        const { boundary1, boundary2 } = this.buildBoundaryMatrices();
        if (!isFiniteMatrix(boundary1) || !isFiniteMatrix(boundary2)) {
            logger.warn("Non-finite boundary matrices detected. Setting H1 to default max/min.");
            this.h1Dimension = 1;
            this.stability = clamp(Math.exp(-this.h1Dimension * 0.2), 0.01, 1);
            return;
        }

        const flatBoundary1 = flattenMatrix(boundary1);
        const flatBoundary2 = flattenMatrix(boundary2);

        if (!flatBoundary1?.flatData || !isFiniteVector(flatBoundary1.flatData)) {
            logger.error("Flat boundary1 is invalid before sending to worker for rank calculation.");
            this.h1Dimension = 1;
            this.stability = clamp(Math.exp(-this.h1Dimension * 0.2), 0.01, 1);
            return;
        }
        if (!flatBoundary2?.flatData || !isFiniteVector(flatBoundary2.flatData)) {
            logger.error("Flat boundary2 is invalid before sending to worker for rank calculation.");
            this.h1Dimension = 1;
            this.stability = clamp(Math.exp(-this.h1Dimension * 0.2), 0.01, 1);
            return;
        }

        let rankB1, rankB2;
        try {
            rankB1 = await runWorkerTask('matrixRank', { matrix: flatBoundary1 }, 10000); // 10s timeout
        } catch (e) {
            logger.error('Error computing rankB1 in worker:', e);
            this.h1Dimension = 1;
            this.stability = clamp(Math.exp(-this.h1Dimension * 0.2), 0.01, 1);
            return;
        }
        try {
            rankB2 = await runWorkerTask('matrixRank', { matrix: flatBoundary2 }, 10000); // 10s timeout
        } catch (e) {
            logger.error('Error computing rankB2 in worker:', e);
            this.h1Dimension = 1;
            this.stability = clamp(Math.exp(-this.h1Dimension * 0.2), 0.01, 1);
            return;
        }
        
        const safeRankB1 = Number.isFinite(rankB1) && rankB1 >= 0 ? rankB1 : 0;
        const safeRankB2 = Number.isFinite(rankB2) && rankB2 >= 0 ? rankB2 : 0;

        const rawH1 = this.graph.edges.length - safeRankB1 - safeRankB2;
        this.h1Dimension = clamp(rawH1, 0, 3); // Clamp H1 to a sensible range
        if (!Number.isFinite(this.h1Dimension)) this.h1Dimension = 1;

        this.stability = clamp(Math.exp(-this.h1Dimension * 0.2), 0.01, 1);
        if (!Number.isFinite(this.stability)) this.stability = 0.5;
    }

    /**
     * Computes the gluing inconsistency across the sheaf, indicating internal contradictions.
     * @returns {Promise<void>}
     */
    async computeGluingInconsistency() {
        let sum = 0;
        for (const [u, v] of this.graph.edges) {
            const stalk_u = this.stalks.get(u);
            const stalk_v = this.stalks.get(v);
            const P_uv = this.projectionMatrices.get(`${u}-${v}`);

            if (!P_uv || !isFiniteVector(stalk_u) || !isFiniteVector(stalk_v) || !isFiniteMatrix(P_uv)) {
                logger.warn(`Skipping inconsistency calculation for edge ${u}-${v} due to non-finite inputs.`);
                continue;
            }

            let projected_u;
            try {
                projected_u = await runWorkerTask('matVecMul', { matrix: flattenMatrix(P_uv), vector: stalk_u }, 5000); // 5s timeout
            } catch (e) {
                logger.error(`Error projecting stalk_u for edge ${u}-${v} in worker:`, e);
                projected_u = vecZeros(this.qDim);
            }
            
            const safeProjected_u = isFiniteVector(projected_u) ? projected_u : vecZeros(this.qDim);
            
            sum += norm2(vecSub(safeProjected_u, stalk_v));
        }
        this.inconsistency = this.graph.edges.length > 0 ? clamp(sum / this.graph.edges.length, 0, 1) : 0;
        if (!Number.isFinite(this.inconsistency)) this.inconsistency = 1.0;
    }

    /**
     * Computes the Gestalt Unity, which quantifies holistic coherence in the sheaf.
     */
    computeGestaltUnity() {
        let sum = 0;
        this.graph.edges.forEach(([u, v]) => {
            const stalk_u = this.stalks.get(u);
            const stalk_v = this.stalks.get(v);
            if (isFiniteVector(stalk_u) && isFiniteVector(stalk_v)) {
                const diffNorm = norm2(vecSub(stalk_u, stalk_v));
                if (Number.isFinite(diffNorm)) {
                    sum += Math.exp(-diffNorm * this.beta);
                }
            }
        });
        this.gestaltUnity = this.graph.edges.length > 0 ? clamp(sum / this.graph.edges.length, 0.05, 0.99) : 0.05;
        if (!Number.isFinite(this.gestaltUnity)) this.gestaltUnity = 0.05;
    }

    /**
     * Computes Integrated Information (Phi), a measure of consciousness.
     * @returns {Promise<void>}
     */
    async computeIntegratedInformation() {
        const validStates = this.windowedStates.filter(isFiniteVector);
        if (validStates.length < Math.max(4, this.stateDim + this.qDim)) { // Need enough samples for meaningful covariance
            logger.warn('Not enough valid states for meaningful covariance calculation. Using base Phi.');
            this.phi = clamp(0.5 + (this.gestaltUnity || 0.1) * (this.stability || 0.1), 0.01, 5);
            return;
        }
        let cov;
        try {
            cov = await runWorkerTask('covarianceMatrix', { states: validStates, eps: this.eps }, 10000); // 10s timeout
        } catch (e) {
            logger.error('Error computing covarianceMatrix in worker:', e);
            this.phi = clamp(0.5 + (this.gestaltUnity || 0.1) * (this.stability || 0.1), 0.01, 5);
            return;
        }

        if (!isFiniteMatrix(cov)) {
            logger.warn("Non-finite covariance matrix. Setting MI to default.");
            this.phi = clamp(0.5 + (this.gestaltUnity || 0.1) * (this.stability || 0.1), 0.01, 5);
            return;
        }

        const MI_val = logDeterminantFromDiagonal(cov);
        const MI = Number.isFinite(MI_val) ? Math.abs(MI_val) * 0.1 + 1e-6 : 1e-6; // Ensure MI is positive and non-zero
        
        const safeStability = Number.isFinite(this.stability) ? this.stability : 0.1;
        const safeGestaltUnity = Number.isFinite(this.gestaltUnity) ? this.gestaltUnity : 0.1;
        const safeInconsistency = Number.isFinite(this.inconsistency) ? this.inconsistency : 1.0;

        this.phi = clamp(Math.log(1 + MI) * safeStability * safeGestaltUnity * Math.exp(-safeInconsistency), 0.01, 5);
        if (!Number.isFinite(this.phi)) this.phi = 0.01;
    }

    /**
     * Updates the visual activity of the sheaf graph vertices based on stalk norms.
     */
    visualizeActivity() {
        this.graph.vertices.forEach((vertexName, idx) => {
            const el = document.getElementById(`vertex-${idx}`);
            if (!el) return;
            const stalk = this.stalks.get(vertexName) || vecZeros(this.qDim);
            const norm = norm2(stalk);
            const intensity = Number.isFinite(norm) ? clamp(norm / Math.sqrt(this.qDim), 0, 1) : 0;
            el.classList.toggle('active', intensity > 0.5);
            const hue = 0; // Fixed hue for general visualization unless active
            const saturation = 100;
            const lightness = 50 + intensity * 40; // Makes it brighter with higher intensity
            
            // Set default/inactive color
            el.style.background = `radial-gradient(circle, hsl(${hue}, ${saturation}%, ${lightness}%), hsl(${hue}, ${saturation * 0.8}%, ${lightness * 0.6}%))`;

            // If active, use the greenish pulse color
            if (intensity > 0.5) {
                 el.style.background = `radial-gradient(circle, #00ff99, #00cc66)`;
            }
        });
    }

    /**
     * Adaptively tunes the sheaf's internal parameters (alpha, beta, gamma)
     * based on current system stability, inconsistency, Gestalt unity, and H1 dimension.
     */
    tuneParameters() {
        const currentStability = Number.isFinite(this.stability) ? this.stability : 0.5;
        const currentInconsistency = Number.isFinite(this.inconsistency) ? this.inconsistency : 0.5;
        const currentGestaltUnity = Number.isFinite(this.gestaltUnity) ? this.gestaltUnity : 0.5;
        const currentH1Dimension = Number.isFinite(this.h1Dimension) ? this.h1Dimension : 1;

        // Tune alpha: Increase responsiveness (alpha) if consistency is low or H1 is high (needs more input to stabilize)
        // Decrease if stability is high and inconsistency is low (system is balanced, avoid over-reactivity)
        this.alpha = clamp(this.alpha * (1 + 0.02 * (1 - currentStability)) * (1 + 0.01 * currentInconsistency) * (1 + 0.005 * currentH1Dimension), 0.01, 1);

        // Tune beta: Increase diffusion strength (beta) to enhance unity, especially if Gestalt unity is low,
        // but slightly reduce if H1 is very high to prevent over-complexity.
        this.beta = clamp(this.beta * (1 + 0.02 * (1 - currentGestaltUnity)) * (1 - 0.01 * currentH1Dimension), 0.01, 1);
        
        // Tune gamma: Adjust learning rate (gamma). Lower it if inconsistency or H1 is high (system is chaotic, slow down changes),
        // Increase slightly if stability is very high but learning seems slow.
        this.gamma = clamp(this.gamma * (1 - 0.05 * currentH1Dimension) * (1 - 0.02 * currentInconsistency) * (1 + 0.01 * currentStability), 0.01, 0.5);
        
        logger.info(`Tuned parameters: Alpha=${this.alpha.toFixed(3)}, Beta=${this.beta.toFixed(3)}, Gamma=${this.gamma.toFixed(3)}`);
    }
}
/**
 * Represents an Ontological World Model (OWM) for an AI, combining a Qualia Sheaf with a Recurrent Neural Network (LSTM-like).
 * It predicts future states and Q-values for actions.
 */
class OntologicalWorldModel {
    /**
     * @param {number} stateDim - Dimension of the input state vector.
     * @param {number} actionDim - Dimension of the action space.
     * @param {number} qDim - Dimension of qualia vectors.
     * @param {number[]} hiddenSizes - Array of hidden layer sizes for the recurrent network.
     * @param {boolean} isPlayerTwo - True if this OWM belongs to the second player (AI).
     */
    constructor(stateDim = 13, actionDim = 4, qDim = 7, hiddenSizes = [64, 64], isPlayerTwo = false) {
        this.stateDim = stateDim;
        this.actionDim = actionDim;
        this.isPlayerTwo = isPlayerTwo;
        this.recurrentStateSize = hiddenSizes[hiddenSizes.length - 1]; // Size of our LSTM-like state
        
        // The sheaf still operates on the core conceptual part of the state (the first 8 elements)
        this.qualiaSheaf = new EnhancedQualiaSheaf(null, 8, qDim, 0.1, 0.1, 0.05); // StateDim for sheaf explicitly 8
        this.qDim = this.qualiaSheaf.qDim; // Use the canonical qDim from the sheaf

        // Define the expected length of the qualia part of the input
        this.expectedQualiaInputLength = this.qualiaSheaf.graph.vertices.length * this.qDim;

        // Define the total input dimension expected by the NN for current state + qualia
        this.inputDim = this.stateDim + this.expectedQualiaInputLength;

        this.hiddenState = vecZeros(this.recurrentStateSize); // Use this.recurrentStateSize
        this.cellState = vecZeros(this.recurrentStateSize); // Use this.recurrentStateSize

        const combinedInputSize = this.inputDim + this.recurrentStateSize; // Use this.recurrentStateSize
        const weightScale = Math.sqrt(2.0 / combinedInputSize); // Glorot/Xavier initialization approximation

        this.Wf = randomMatrix(this.recurrentStateSize, combinedInputSize, weightScale); // Forget gate
        this.Wi = randomMatrix(this.recurrentStateSize, combinedInputSize, weightScale); // Input gate
        this.Wc = randomMatrix(this.recurrentStateSize, combinedInputSize, weightScale); // Cell state candidate
        this.Wo = randomMatrix(this.recurrentStateSize, combinedInputSize, weightScale); // Output gate
        this.bf = vecZeros(this.recurrentStateSize);
        this.bi = vecZeros(this.recurrentStateSize);
        this.bc = vecZeros(this.recurrentStateSize);
        this.bo = vecZeros(this.recurrentStateSize);
        
        // Output heads are now fed from the recurrent hidden state
        const qValueScale = Math.sqrt(2.0 / (this.recurrentStateSize + this.actionDim)); // Use this.recurrentStateSize
        this.qValueHead = { W: randomMatrix(this.actionDim, this.recurrentStateSize, qValueScale), b: vecZeros(this.actionDim) };
        
        const statePredScale = Math.sqrt(2.0 / (this.recurrentStateSize + this.stateDim)); // Use this.recurrentStateSize
        this.statePredHead = { W: randomMatrix(this.stateDim, this.recurrentStateSize, statePredScale), b: vecZeros(this.stateDim) };

        this.attentionWeights = randomMatrix(this.qDim, this.inputDim, 0.1); // Attention weights dim: qDim x inputDim
        this.lastSoftmaxScores = vecZeros(this.qDim); // Size qDim
        
        this.freeEnergy = 0;
        this.predictionError = 0;
        this.ready = false;
        this.lastActivations = [];

        logger.info(`OWM constructed (${isPlayerTwo ? 'AI' : 'Player'}): stateDim=${this.stateDim}, inputDim=${this.inputDim}, qualiaSheaf.qDim=${this.qualiaSheaf.qDim}, expectedQualiaInputLength=${this.expectedQualiaInputLength}`);
    }

    /**
     * Initializes the OWM and its underlying Qualia Sheaf.
     * @returns {Promise<void>}
     */
    async initialize() {
        logger.info(`OWM.initialize() (${this.isPlayerTwo ? 'AI' : 'Player'}) called.`);
        try {
            await this.qualiaSheaf.initialize();
            this.ready = true;
            logger.info(`Recurrent OWM for ${this.isPlayerTwo ? 'AI' : 'Player'} ready.`);
        } catch (e) {
            logger.error(`Error during Recurrent OWM initialization (${this.isPlayerTwo ? 'AI' : 'Player'}):`, e);
            this.ready = false;
            throw e; // Re-throw to propagate to MainApp
        }
    }

    /**
     * Performs a forward pass through the recurrent neural network.
     * @param {Float32Array} input - The concatenated state and qualia input.
     * @returns {Promise<{qValues: Float32Array, nextState: Float32Array, activations: Float32Array[]}>}
     *          Predicted Q-values, next state, and intermediate activations.
     */
    async forward(input) {
        if (!isFiniteVector(input) || input.length !== this.inputDim) {
            logger.error('OWM.forward: Invalid input. Returning zeros.', {expected: this.inputDim, got: input.length});
            this.resetRecurrentState(); // Attempt to recover from bad input
            return { qValues: vecZeros(this.actionDim), nextState: vecZeros(this.stateDim), activations: [] };
        }
        
        const activations = [input.slice()];
        
        // --- NEW: LSTM-like Recurrent Block ---
        const combinedInput = new Float32Array([...input, ...this.hiddenState]);
        if (!isFiniteVector(combinedInput)) {
            logger.error('OWM.forward: Combined input for LSTM is non-finite. Resetting hidden/cell states and returning zeros.');
            this.resetRecurrentState(); // Attempt to recover
            return { qValues: vecZeros(this.actionDim), nextState: vecZeros(this.stateDim), activations: [] };
        }

        const Wf_flat = flattenMatrix(this.Wf);
        const Wi_flat = flattenMatrix(this.Wi);
        const Wc_flat = flattenMatrix(this.Wc);
        const Wo_flat = flattenMatrix(this.Wo);
        
        let ft, it, c_tilde, ot;

        try {
            ft = sigmoidVec(vecAdd(await runWorkerTask('matVecMul', {matrix: Wf_flat, vector: combinedInput}, 2000), this.bf)); // Increased timeout
            it = sigmoidVec(vecAdd(await runWorkerTask('matVecMul', {matrix: Wi_flat, vector: combinedInput}, 2000), this.bi)); // Increased timeout
            c_tilde = tanhVec(vecAdd(await runWorkerTask('matVecMul', {matrix: Wc_flat, vector: combinedInput}, 2000), this.bc)); // Increased timeout
            
            this.cellState = vecAdd(vecMul(ft, this.cellState), vecMul(it, c_tilde));
            if (!isFiniteVector(this.cellState)) {
                logger.error('OWM.forward: Cell state became non-finite. Resetting.');
                this.cellState.fill(0);
            }
            activations.push(this.cellState.slice());

            ot = sigmoidVec(vecAdd(await runWorkerTask('matVecMul', {matrix: Wo_flat, vector: combinedInput}, 2000), this.bo)); // Increased timeout
            this.hiddenState = vecMul(ot, tanhVec(this.cellState));
            if (!isFiniteVector(this.hiddenState)) {
                logger.error('OWM.forward: Hidden state became non-finite. Resetting.');
                this.hiddenState.fill(0);
            }
            activations.push(this.hiddenState.slice());
        } catch (e) {
            logger.error('OWM.forward: Error during recurrent step:', e);
            this.resetRecurrentState(); // Attempt to recover
            return { qValues: vecZeros(this.actionDim), nextState: vecZeros(this.stateDim), activations: [] };
        }
        // --- END Recurrent Block ---

        // Output heads now take the new hiddenState as input
        let qValues, nextState;
        try {
            qValues = vecAdd(await runWorkerTask('matVecMul', { matrix: flattenMatrix(this.qValueHead.W), vector: this.hiddenState }, 2000), this.qValueHead.b); // Increased timeout
            nextState = vecAdd(await runWorkerTask('matVecMul', { matrix: flattenMatrix(this.statePredHead.W), vector: this.hiddenState }, 2000), this.statePredHead.b); // Increased timeout
        } catch (e) {
            logger.error('OWM.forward: Error during output head calculation:', e);
            return { qValues: vecZeros(this.actionDim), nextState: vecZeros(this.stateDim), activations: [] };
        }
        
        if (!isFiniteVector(qValues)) { logger.warn('OWM.forward: Q-values are non-finite. Returning zeros.'); qValues = vecZeros(this.actionDim); }
        if (!isFiniteVector(nextState)) { logger.warn('OWM.forward: Next state prediction is non-finite. Returning zeros.'); nextState = vecZeros(this.stateDim); }

        activations.push(qValues.slice()); // Push Q-values as final activation layer for visualization
        
        return { qValues, nextState, activations };
    }

    /**
     * Applies an attention mechanism to the input, weighting different parts based on their relevance to qualia.
     * @param {Float32Array} input - The combined state and qualia input.
     * @returns {Float32Array} The attended input vector.
     */
    applyAttention(input) {
        if (!isFiniteVector(input) || input.length !== this.inputDim) {
            logger.error('OWM.applyAttention: Invalid input. Returning original input.', {expected: this.inputDim, got: input.length});
            this.lastSoftmaxScores.fill(0); // Reset scores
            return input;
        }

        const scores = this.attentionWeights.map(w => dot(w, input));
        if (!isFiniteVector(scores)) {
            logger.warn('OWM.applyAttention: Scores became non-finite. Returning original input.');
            this.lastSoftmaxScores.fill(0);
            return input;
        }

        const maxScore = scores.length > 0 ? Math.max(...scores) : 0;
        const expScores = scores.map(s => Math.exp(s - maxScore)); // Subtract max for numerical stability
        const sumExpScores = expScores.reduce((s, x) => s + x, 1e-10); // Add epsilon to prevent division by zero
        const softmaxScores = new Float32Array(expScores.map(s => s / sumExpScores));
        
        if (!isFiniteVector(softmaxScores)) {
            logger.warn('OWM.applyAttention: Softmax scores became non-finite. Returning original input.');
            this.lastSoftmaxScores.fill(0);
            return input;
        }

        this.lastSoftmaxScores = softmaxScores;

        const att = vecZeros(input.length);
        for (let i = 0; i < softmaxScores.length; i++) {
            if (!Number.isFinite(softmaxScores[i])) continue; // Skip non-finite scores
            for (let j = 0; j < input.length; j++) {
                att[j] += softmaxScores[i] * (input[j] || 0);
            }
        }
        const weightedAttended = vecAdd(input, vecScale(att, this.qualiaSheaf.beta));
        return isFiniteVector(weightedAttended) ? weightedAttended : input; // Fallback to original if non-finite
    }

    /**
     * Predicts Q-values and next state based on the current state.
     * Involves qualia diffusion, attention, and the recurrent neural network forward pass.
     * @param {Float32Array} state - The current state vector.
     * @returns {Promise<{qValues: Float32Array, activations: Float32Array[], corrupted: boolean}>}
     *          Predicted Q-values, intermediate activations, and a flag indicating if corruption occurred.
     */
    async predict(state) {
        if (!this.ready) {
            logger.warn('OWM not ready for prediction.');
            return { qValues: vecZeros(this.actionDim), activations: [], corrupted: true };
        }
        if (!isFiniteVector(state) || state.length !== this.stateDim) {
            logger.error(`OWM.predict: Invalid state vector received. Expected length ${this.stateDim}, got ${state.length}.`, { state });
            return { qValues: vecZeros(this.actionDim), activations: [], corrupted: true };
        }

        let corruptedFlag = false;

        // Diffuse qualia - this can modify the sheaf's internal state (stalks, metrics)
        try {
            // The sheaf only cares about the first 8 conceptual elements of the state vector
            await this.qualiaSheaf.diffuseQualia(state.slice(0, 8));
        } catch (e) {
            logger.error('OWM.predict: Error during qualia diffusion:', e);
            corruptedFlag = true;
        }
        
        const qualiaStalksMap = this.qualiaSheaf.stalks;
        let finalQualiaArray = new Float32Array(this.expectedQualiaInputLength); // Initialize with zeros

        if (qualiaStalksMap instanceof Map && qualiaStalksMap.size > 0) {
            let offset = 0;
            for (const vertexName of this.qualiaSheaf.graph.vertices) {
                let stalk = qualiaStalksMap.get(vertexName);
                if (!stalk || !isFiniteVector(stalk) || stalk.length !== this.qDim) {
                    logger.warn(`OWM.predict: Corrupted or missing stalk for vertex "${vertexName}" in qualiaStalksMap. Replacing with zeros.`);
                    stalk = vecZeros(this.qDim); 
                    corruptedFlag = true;
                }
                
                for (let i = 0; i < this.qDim; i++) {
                    finalQualiaArray[offset + i] = Number.isFinite(stalk[i]) ? clamp(stalk[i], -1, 1) : 0;
                }
                offset += this.qDim;
            }
        } else {
            logger.warn('qualiaStalksMap is empty or not a Map, using all-zero qualia vector for input. Flagging as corrupted.');
            corruptedFlag = true;
        }

        if (!isFiniteVector(finalQualiaArray) || finalQualiaArray.length !== this.expectedQualiaInputLength) {
             logger.error(`FATAL: finalQualiaArray became non-finite or wrong length after construction. Resetting to all zeros and flagging corrupted.`);
             finalQualiaArray = vecZeros(this.expectedQualiaInputLength);
             corruptedFlag = true;
        }

        const input = new Float32Array([...state, ...finalQualiaArray]);
        
        if (input.length !== this.inputDim || !isFiniteVector(input)) {
             logger.error(`FATAL: Input size mismatch or non-finite values just before attention. Expected ${this.inputDim}, got ${input.length}. Flagging corrupted.`);
             return { qValues: vecZeros(this.actionDim), activations: [], corrupted: true };
        }

        const attended = this.applyAttention(input);
        
        let qValues, nextState, activations;
        try {
            const forwardResult = await this.forward(attended);
            qValues = forwardResult.qValues;
            nextState = forwardResult.nextState;
            activations = forwardResult.activations;
        } catch (e) {
            logger.error('OWM.predict: Error during forward pass:', e);
            corruptedFlag = true;
            qValues = vecZeros(this.actionDim);
            nextState = vecZeros(this.stateDim);
            activations = [];
        }

        const error = norm2(vecSub(nextState, state));
        this.predictionError = clamp(error, 0, 10);
        if (!Number.isFinite(this.predictionError)) { logger.warn('OWM.predict: Prediction error is non-finite. Resetting to 0.'); this.predictionError = 0; corruptedFlag = true; }

        this.freeEnergy = 0.85 * (this.freeEnergy || 0) + 0.15 * (this.predictionError * 0.5 + (this.qualiaSheaf.h1Dimension || 0));
        this.freeEnergy = clamp(this.freeEnergy, 0, 10);
        if (!Number.isFinite(this.freeEnergy)) { logger.warn('OWM.predict: Free energy is non-finite. Resetting to 0.'); this.freeEnergy = 0; corruptedFlag = true; }

        this.lastActivations = activations;

        return { qValues, activations, corrupted: corruptedFlag };
    }

    /**
     * Performs a learning step using Q-learning.
     * @param {Float32Array} state - The current state.
     * @param {number} actionIndex - The index of the action taken.
     * @param {number} reward - The reward received.
     * @param {Float32Array} nextState - The state after taking the action.
     * @param {boolean} isDone - True if the episode is finished.
     * @param {number} learningRate - The learning rate for weight updates.
     * @param {number} gamma - The discount factor for future rewards.
     * @returns {Promise<void>}
     */
    async learn(state, actionIndex, reward, nextState, isDone, learningRate = 0.01, gamma = 0.99) {
        if (!isFiniteVector(state) || !isFiniteVector(nextState) || !Number.isFinite(reward) || !Number.isFinite(actionIndex)) {
            logger.warn('OWM.learn: Invalid input (state, nextState, reward, or actionIndex). Skipping learning step.');
            return;
        }
        if (actionIndex < 0 || actionIndex >= this.actionDim) {
            logger.warn(`OWM.learn: Invalid actionIndex ${actionIndex}. Skipping learning step.`);
            return;
        }

        // Use a version of predict that doesn't flag corruption for learning purposes
        // to avoid feedback loops if the state is temporarily noisy.
        const { qValues: currentQValues } = await this.predict(state); // Corruption info is ignored here
        const { qValues: nextQValues } = await this.predict(nextState);
        
        const maxNextQ = isDone ? 0 : Math.max(...nextQValues);

        const targetQ = (Number.isFinite(reward) ? reward : 0) + (Number.isFinite(gamma) ? gamma : 0) * (Number.isFinite(maxNextQ) ? maxNextQ : 0);
        const currentQForAction = (currentQValues && Number.isFinite(currentQValues[actionIndex])) ? currentQValues[actionIndex] : 0;
        const tdError = targetQ - currentQForAction;

        const lastRecurrentState = this.lastActivations[2]; // hiddenState (index 2 in activations array)
        if (lastRecurrentState && isFiniteVector(lastRecurrentState)) {
            for (let j = 0; j < lastRecurrentState.length; j++) {
                const deltaW = (Number.isFinite(learningRate) ? learningRate : 0) * (Number.isFinite(tdError) ? tdError : 0) * (Number.isFinite(lastRecurrentState[j]) ? lastRecurrentState[j] : 0);
                if (Number.isFinite(deltaW)) {
                    this.qValueHead.W[actionIndex][j] = (Number.isFinite(this.qValueHead.W[actionIndex][j]) ? this.qValueHead.W[actionIndex][j] : 0) + deltaW;
                } else {
                    // logger.warn('OWM.learn: Non-finite deltaW calculated. Skipping update for this weight.'); // Removed verbose log
                }
            }
            const deltaB = (Number.isFinite(learningRate) ? learningRate : 0) * (Number.isFinite(tdError) ? tdError : 0);
            if (Number.isFinite(deltaB)) {
                this.qValueHead.b[actionIndex] = (Number.isFinite(this.qValueHead.b[actionIndex]) ? this.qValueHead.b[actionIndex] : 0) + deltaB;
            } else {
                // logger.warn('OWM.learn: Non-finite deltaB calculated. Skipping update for this bias.'); // Removed verbose log
            }
        } else {
            logger.warn('OWM.learn: lastRecurrentState is invalid or missing. Skipping learning update.');
        }
    }

    /**
     * Resets the internal recurrent state (hidden and cell states) of the OWM.
     */
    resetRecurrentState() {
        this.hiddenState.fill(0);
        this.cellState.fill(0);
        logger.info(`OWM recurrent state for ${this.isPlayerTwo ? 'AI' : 'Player'} has been reset.`);
    }
}
/**
 * Implements a Reinforcement Learning agent using an Ontological World Model.
 * Manages exploration-exploitation balance (epsilon-greedy) and state representation.
 */
class LearningAI {
    /**
     * @param {OntologicalWorldModel} worldModel - The OWM this AI will use.
     * @param {ThreeDeeGame} game - The game instance, needed for raycasting.
     * @param {boolean} isPlayerTwo - True if this AI controls the second agent.
     * @param {number} aiResponseTime - Number of frames between AI decisions.
     */
    constructor(worldModel, game, isPlayerTwo = false, aiResponseTime = 3) {
        this.worldModel = worldModel;
        this.game = game; // Access to game for raycasting
        this.isPlayerTwo = isPlayerTwo;
        this.aiResponseTime = Math.max(1, aiResponseTime);
        this.actionQueue = [];

        this.epsilon = 1.0;
        this.epsilonMin = 0.05;
        this.epsilonDecay = 0.9995;
        this.learningRate = 0.01;
        
        this.lastStateVec = vecZeros(this.worldModel.stateDim);
        this.lastActionIndex = 3; // Corresponds to 'IDLE'
        this.lastActivations = [];
        this.avgQValue = 0;
    }

    /**
     * Creates a normalized state vector from the current 3D game state, now including raycast data.
     * @param {Object} gameState - The raw game state object.
     * @returns {Float32Array} The normalized state vector.
     */
    createStateVector(gameState) {
        const agent = this.isPlayerTwo ? gameState.ai : gameState.player;
        const opponent = this.isPlayerTwo ? gameState.player : gameState.ai;
        const target = this.isPlayerTwo ? gameState.aiTarget : gameState.playerTarget;

        const worldHalfSize = ThreeDeeGame.WORLD_SIZE / 2;
        const worldSize = ThreeDeeGame.WORLD_SIZE;
        
        // --- Core conceptual state (for the sheaf) ---
        const agentX_norm = (agent.x || 0) / worldHalfSize;
        const agentZ_norm = (agent.z || 0) / worldHalfSize;
        const agentRot_norm = (agent.rotY || 0) / Math.PI;
        const targetX_norm = (target.x || 0) / worldHalfSize;
        const targetZ_norm = (target.z || 0) / worldHalfSize;
        const vecX = (target.x || 0) - (agent.x || 0);
        const vecZ = (target.z || 0) - (agent.z || 0);
        const dist = Math.sqrt(vecX*vecX + vecZ*vecZ);
        const vecX_norm = vecX / worldSize;
        const vecZ_norm = vecZ / worldSize;
        const dist_norm = dist / worldSize;

        // --- New Sensory Data: Raycasting ---
        const agent3D = this.isPlayerTwo ? this.game.ai : this.game.player;
        const rayDetections = this.game.getRaycastDetections(agent3D); // Get normalized ray values
        const rayLeft_norm = rayDetections.left;
        const rayCenter_norm = rayDetections.center;
        const rayRight_norm = rayDetections.right;

        // --- New Sensory Data: Opponent Awareness ---
        const oppVecX = (opponent.x || 0) - (agent.x || 0);
        const oppVecZ = (opponent.z || 0) - (agent.z || 0);
        const oppVecX_norm = oppVecX / worldSize;
        const oppVecZ_norm = oppVecZ / worldSize;

        const stateVec = new Float32Array([
            // Core state (8 elements)
            agentX_norm, agentZ_norm, agentRot_norm,
            targetX_norm, targetZ_norm,
            vecX_norm, vecZ_norm, dist_norm,
            // Sensory state (5 elements)
            rayLeft_norm, rayCenter_norm, rayRight_norm,
            oppVecX_norm, oppVecZ_norm
        ]);

        const clampedStateVec = new Float32Array(stateVec.map(v => Number.isFinite(v) ? clamp(v, -1, 1) : 0));

        if (!isFiniteVector(clampedStateVec) || clampedStateVec.length !== this.worldModel.stateDim) {
            logger.error(`LearningAI.createStateVector: Generated state vector is invalid. Returning zeros.`, {clampedStateVec});
            return vecZeros(this.worldModel.stateDim);
        }
        return clampedStateVec;
    }

    /**
     * Makes a decision for the AI action based on epsilon-greedy policy.
     * @param {Object} gameState - The current game state.
     * @returns {Promise<{action: number[], activations: Float32Array[], corrupted: boolean, chosenActionIndex: number}>}
     */
    async makeDecision(gameState) {
        if (this.actionQueue.length >= this.aiResponseTime) {
            return this.actionQueue.shift();
        }

        const actions = [
            { name: 'MOVE_FORWARD', vec: [1, 0, 0, 0] }, 
            { name: 'TURN_LEFT', vec: [0, 1, 0, 0] }, 
            { name: 'TURN_RIGHT', vec: [0, 0, 1, 0] },
            { name: 'IDLE', vec: [0, 0, 0, 1] }
        ];
        let actionIndex = 3; // Default to IDLE

        const stateVec = this.createStateVector(gameState);
        this.lastStateVec = stateVec;

        const { qValues, activations, corrupted } = await this.worldModel.predict(stateVec);
        this.lastActivations = activations;

        if (corrupted) {
            logger.warn(`LearningAI (${this.isPlayerTwo ? 'AI' : 'Opponent'}): World model predicted a corrupted state. Defaulting to IDLE.`);
            this.lastActionIndex = 3; // IDLE
            const decision = { action: actions[3].vec, activations: this.lastActivations, corrupted: true, chosenActionIndex: 3 };
            this.actionQueue.push(decision);
            return this.actionQueue.shift() || decision;
        }

        if (Math.random() < this.epsilon) {
            actionIndex = Math.floor(Math.random() * actions.length);
        } else {
            if (qValues && isFiniteVector(qValues)) {
                actionIndex = qValues.indexOf(Math.max(...qValues));
                this.avgQValue = qValues.reduce((a, b) => a + b, 0) / qValues.length;
            } else {
                logger.warn(`LearningAI (${this.isPlayerTwo ? 'AI' : 'Opponent'}): Received invalid Q-values, defaulting to IDLE.`);
                actionIndex = 3;
                this.avgQValue = 0;
            }
        }
        
        this.lastActionIndex = actionIndex;
        const decision = { action: actions[actionIndex].vec, activations: this.lastActivations, corrupted: false, chosenActionIndex: actionIndex };
        this.actionQueue.push(decision);

        return this.actionQueue.shift() || decision;
    }

    /**
     * Performs a Q-learning update step.
     * @param {number} reward - The reward received from the environment.
     * @param {Object} newGameState - The new state of the game.
     * @param {boolean} isDone - True if the episode is finished.
     * @returns {Promise<void>}
     */
    async learn(reward, newGameState, isDone) {
        const nextStateVec = this.createStateVector(newGameState);

        // --- Add intrinsic motivation ---
        const curiosityBonus = clamp(this.worldModel.predictionError, 0, 1) * 0.01; // Small reward for being surprised
        let totalReward = reward + curiosityBonus;

        // --- Add idle penalty ---
        if (this.lastActionIndex === 3) { // 3 is the index for IDLE
            totalReward -= 0.01;
        }
        
        await this.worldModel.learn(this.lastStateVec, this.lastActionIndex, totalReward, nextStateVec, isDone, this.learningRate);
        
        if (this.epsilon > this.epsilonMin) {
            this.epsilon *= this.epsilonDecay;
        }

        const uncertaintyFactor = 1 + clamp(this.worldModel.predictionError, 0, 5) * 0.05;
        this.epsilon = clamp(this.epsilon * uncertaintyFactor, this.epsilonMin, 1.0);
        this.epsilon = Number.isFinite(this.epsilon) ? this.epsilon : this.epsilonMin;
    }

    /**
     * Resets the AI's internal state and learning parameters.
     */
    reset() {
        this.worldModel.resetRecurrentState();
        this.epsilon = 1.0;
        this.avgQValue = 0;
        this.actionQueue = [];
        this.learningRate = 0.01;
        logger.info(`LearningAI for ${this.isPlayerTwo ? 'AI' : 'Opponent'} has been reset.`);
    }
}
// NEW: StrategicAI for Meta-Learning
/**
 * Monitors a LearningAI's performance and internal metrics to adapt its learning rate and exploration.
 * This acts as a meta-learning agent.
 */
class StrategicAI {
    /**
     * @param {LearningAI} learningAI - The learning AI to manage.
     */
    constructor(learningAI) {
        this.learningAI = learningAI;
        this.rewardHistory = [];
        this.HISTORY_SIZE = 200; // Analyze the last 200 steps
        this.epsilonModulationRate = 0.005; // Rate for epsilon adjustment
        this.learningRateModulationRate = 0.005; // Rate for learning rate adjustment
    }

    /**
     * Observes the reward received by the learning AI.
     * @param {number} reward - The reward received.
     */
    observe(reward) {
        if (Number.isFinite(reward)) {
            this.rewardHistory.push(reward);
            if (this.rewardHistory.length > this.HISTORY_SIZE) {
                this.rewardHistory.shift();
            }
        }
    }

    /**
     * Modulates the `epsilon` and `learningRate` of the associated `LearningAI`
     * based on performance and internal consciousness metrics.
     */
    modulateParameters() {
        if (this.rewardHistory.length < this.HISTORY_SIZE / 2) return;

        const avgReward = this.rewardHistory.reduce((a, b) => a + b, 0) / this.rewardHistory.length;
        const predError = Number.isFinite(this.learningAI.worldModel.predictionError) ? this.learningAI.worldModel.predictionError : 0;
        const gestaltUnity = Number.isFinite(this.learningAI.worldModel.qualiaSheaf.gestaltUnity) ? this.learningAI.worldModel.qualiaSheaf.gestaltUnity : 0.5;
        const h1Dimension = Number.isFinite(this.learningAI.worldModel.qualiaSheaf.h1Dimension) ? this.learningAI.worldModel.qualiaSheaf.h1Dimension : 1.0;

        // If performance is poor (low avg reward), increase learning rate and exploration
        if (avgReward < 0.05 && predError > 1.0) { // If not finding target and confused
            this.learningAI.learningRate = clamp(this.learningAI.learningRate * (1 + this.learningRateModulationRate), 0.001, 0.05);
            this.learningAI.epsilon = clamp(this.learningAI.epsilon * (1 + this.epsilonModulationRate), this.learningAI.epsilonMin, 1.0);
        } else if (avgReward > 0.2 && predError < 0.5) { // If doing well and confident
            this.learningAI.learningRate = clamp(this.learningAI.learningRate * (1 - this.learningRateModulationRate), 0.001, 0.05);
        }

        const explorationModifier = (1 - gestaltUnity) + (h1Dimension * 0.1);
        this.learningAI.epsilon = clamp(this.learningAI.epsilon * (1 + (explorationModifier - 0.5) * 0.01), this.learningAI.epsilonMin, 1.0);

        this.learningAI.learningRate = Number.isFinite(this.learningAI.learningRate) ? this.learningAI.learningRate : 0.01;
        this.learningAI.epsilon = Number.isFinite(this.learningAI.epsilon) ? this.learningAI.epsilon : this.learningAI.epsilonMin;
    }
}
        /**
         * Represents the 3D game environment, handling physics, scoring, and rendering with Three.js.
         */
        class ThreeDeeGame {
            static WORLD_SIZE = 100;
            static AGENT_SPEED = 0.8;
            static AGENT_TURN_SPEED = 0.05;
            static MAX_RAY_DISTANCE = 30;

            constructor(canvas) {
                this.canvas = canvas;
                // FIX: Ensure initial width/height are at least 1 to prevent division by zero for camera aspect
                this.width = Math.max(1, canvas.clientWidth);
                this.height = Math.max(1, canvas.clientHeight);

                // Scene setup
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0a0a15);
                
                // Camera: Use validated width/height
                this.camera = new THREE.PerspectiveCamera(75, this.width / this.height, 0.1, 1000);
                this.camera.position.set(0, 80, 60);
                this.camera.lookAt(0, 0, 0);

                // Renderer: Use validated width/height
                this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
                this.renderer.setSize(this.width, this.height);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;

                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404060, 1.5);
                this.scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
                directionalLight.position.set(20, 50, 20);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);
                
                this.raycaster = new THREE.Raycaster();
                
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Ensure all lists are initialized for the first reset call
                this.player = null;
                this.ai = null;
                this.playerTarget = null;
                this.aiTarget = null;
                this.ground = null;
                this.obstacles = [];
                this.walls = [];
                this.collidables = []; // Initialize here to prevent issues in the first reset
                
                this.reset();
            }
            
            async resumeAudioContext() {
                if (this.audioContext.state === 'suspended') {
                    return this.audioContext.resume().catch(e => logger.error("Failed to resume AudioContext in 3DGame:", e));
                }
                return Promise.resolve();
            }

            reset() {
                // 1. Full cleanup: Remove all old dynamic objects and dispose of their resources.
                const objectsToDisposeAndRemove = [];
                if (this.player) objectsToDisposeAndRemove.push(this.player);
                if (this.ai) objectsToDisposeAndRemove.push(this.ai);
                if (this.playerTarget) objectsToDisposeAndRemove.push(this.playerTarget);
                if (this.aiTarget) objectsToDisposeAndRemove.push(this.aiTarget);
                this.walls.forEach(w => objectsToDisposeAndRemove.push(w));
                this.obstacles.forEach(o => objectsToDisposeAndRemove.push(o));
                if (this.ground) objectsToDisposeAndRemove.push(this.ground);

                objectsToDisposeAndRemove.forEach(obj => {
                    if (obj.parent) {
                        obj.parent.remove(obj);
                    }
                    if (obj.geometry) {
                        obj.geometry.dispose();
                    }
                    if (obj.material) {
                        if (Array.isArray(obj.material)) {
                            obj.material.forEach(m => m.dispose());
                        } else {
                            obj.material.dispose();
                        }
                    }
                });

                // Clear internal lists for a fresh start
                this.obstacles = [];
                this.walls = [];
                this.collidables = [];
                this.score = { ai: 0, player: 0 };
                
                const worldHalf = ThreeDeeGame.WORLD_SIZE / 2;
                
                // Ground (Always recreate to ensure freshness and proper state)
                const groundGeom = new THREE.PlaneGeometry(ThreeDeeGame.WORLD_SIZE, ThreeDeeGame.WORLD_SIZE);
                const groundMat = new THREE.MeshStandardMaterial({ color: 0x2a2a4a });
                this.ground = new THREE.Mesh(groundGeom, groundMat);
                this.ground.rotation.x = -Math.PI / 2;
                this.ground.receiveShadow = true;
                this.ground.name = 'ground';
                this.scene.add(this.ground);
                this.collidables.push(this.ground);


                // Walls (Always recreate)
                const wallMat = new THREE.MeshStandardMaterial({ color: 0x4a4a6a });
                const wallGeomH = new THREE.BoxGeometry(ThreeDeeGame.WORLD_SIZE + 2, 10, 2); // Length along X, thickness along Z
                const wallGeomV = new THREE.BoxGeometry(2, 10, ThreeDeeGame.WORLD_SIZE + 2); // Length along Z, thickness along X
                
                const createAndAddWall = (geom, mat, x, z, rotY = 0, name) => {
                    const wall = new THREE.Mesh(geom, mat);
                    wall.position.set(x, 5, z);
                    wall.rotation.y = rotY;
                    wall.castShadow = true;
                    wall.receiveShadow = true;
                    wall.name = name;
                    wall.position.x = clamp(wall.position.x, -worldHalf - 1, worldHalf + 1);
                    wall.position.z = clamp(wall.position.z, -worldHalf - 1, worldHalf + 1);

                    this.scene.add(wall);
                    this.walls.push(wall);
                    this.collidables.push(wall);
                };

                // Horizontal walls (length along X, placed at +/- Z boundaries) - No Y-rotation needed
                createAndAddWall(wallGeomH, wallMat, 0, -worldHalf, 0, 'wall1');
                createAndAddWall(wallGeomH, wallMat, 0, worldHalf, 0, 'wall2');
                
                // Vertical walls (length along Z, placed at +/- X boundaries) - No Y-rotation needed
                // Their geometry is already oriented with length along Z.
                createAndAddWall(wallGeomV, wallMat, -worldHalf, 0, 0, 'wall3'); // Changed rotY from Math.PI / 2 to 0
                createAndAddWall(wallGeomV, wallMat, worldHalf, 0, 0, 'wall4'); // Changed rotY from Math.PI / 2 to 0


                // Add Obstacles
                this.addObstacles(8);
                this.obstacles.forEach(obstacle => {
                    if (obstacle && obstacle.isObject3D) {
                        this.collidables.push(obstacle);
                    } else {
                        logger.warn("Invalid obstacle found during reset; not adding to collidables.");
                    }
                });

                // Player Agent
                const playerGeom = new THREE.BoxGeometry(4, 4, 4);
                const playerMat = new THREE.MeshStandardMaterial({ color: 0xff9900 });
                this.player = new THREE.Mesh(playerGeom, playerMat);
                this.player.castShadow = true;
                this.player.name = 'player';
                this.player.position.set(clamp(-worldHalf / 2, -worldHalf + 2, worldHalf - 2), 2, 0);
                this.scene.add(this.player);
                this.collidables.push(this.player);

                // AI Agent
                const aiGeom = new THREE.BoxGeometry(4, 4, 4);
                const aiMat = new THREE.MeshStandardMaterial({ color: 0x44aaff });
                this.ai = new THREE.Mesh(aiGeom, aiMat);
                this.ai.castShadow = true;
                this.ai.name = 'ai';
                this.ai.position.set(clamp(worldHalf / 2, -worldHalf + 2, worldHalf - 2), 2, 0);
                this.scene.add(this.ai);
                this.collidables.push(this.ai);
                
                // Player Target
                const pTargetGeom = new THREE.SphereGeometry(3, 16, 16);
                const pTargetMat = new THREE.MeshStandardMaterial({ color: 0xff9900, emissive: 0xaa6600 });
                this.playerTarget = new THREE.Mesh(pTargetGeom, pTargetMat);
                this.playerTarget.name = 'playerTarget';
                this.scene.add(this.playerTarget);
                this.respawnTarget(this.playerTarget);
                this.collidables.push(this.playerTarget);

                // AI Target
                const aiTargetGeom = new THREE.SphereGeometry(3, 16, 16);
                const aiTargetMat = new THREE.MeshStandardMaterial({ color: 0x44aaff, emissive: 0x2288dd });
                this.aiTarget = new THREE.Mesh(aiTargetGeom, aiTargetMat);
                this.aiTarget.name = 'aiTarget';
                this.scene.add(this.aiTarget);
                this.respawnTarget(this.aiTarget);
                this.collidables.push(this.aiTarget);
                
                // Final filtering of collidables
                this.collidables = this.collidables.filter(obj => obj && obj.isObject3D);

                logger.info(`ThreeDeeGame reset completed. Total collidables: ${this.collidables.length}`);
            }
            /**
             * Casts rays from an agent to detect nearby obstacles.
             * THIS FUNCTION CONTAINS A SECONDARY FIX for raycasting logic.
             * @param {THREE.Mesh} agentMesh - The agent object (this.player or this.ai).
             * @returns {{left: number, center: number, right: number}} Normalized distances (1=close, 0=far).
             */
            addObstacles(count) {
                const worldHalf = ThreeDeeGame.WORLD_SIZE / 2;
                const spawnArea = worldHalf * 0.8;
                const obstacleMat = new THREE.MeshStandardMaterial({ color: 0x886688 });

                for(let i = 0; i < count; i++) {
                    // FIX: Ensure dimensions are always positive and finite, with a minimum size of 1
                    const sx = clamp(4 + Math.random() * 12, 1, 20);
                    const sz = clamp(4 + Math.random() * 12, 1, 20);
                    
                    const obstacleGeom = new THREE.BoxGeometry(sx, 10, sz);
                    const obstacle = new THREE.Mesh(obstacleGeom, obstacleMat);
                    
                    // FIX: Ensure position components are finite and within reasonable bounds
                    const ox = clamp((Math.random() - 0.5) * spawnArea, -worldHalf + sx / 2, worldHalf - sx / 2);
                    const oz = clamp((Math.random() - 0.5) * spawnArea, -worldHalf + sz / 2, worldHalf - sz / 2);

                    obstacle.position.set(ox, 5, oz); // Y position is always 5
                    obstacle.name = `obstacle-${i}`; // For debugging
                    
                    // Defensive check: Log if position is still non-finite after clamping
                    if (!Number.isFinite(obstacle.position.x) || !Number.isFinite(obstacle.position.z)) {
                        logger.error(`Non-finite obstacle position detected during creation for obstacle ${i}! Skipping this obstacle.`);
                        continue; // Skip adding this potentially corrupted obstacle
                    }

                    obstacle.castShadow = true;
                    // Removed userData.isDynamic as all objects are now fully managed by reset's cleanup logic.
                    this.obstacles.push(obstacle);
                    this.scene.add(obstacle);
                }
            }


            respawnTarget(target) {
                const worldHalf = ThreeDeeGame.WORLD_SIZE / 2;
                const spawnRadius = worldHalf * 0.8;
                // FIX: Ensure target positions are finite and not too close to the world edges
                const tx = clamp((Math.random()-0.5) * spawnRadius, -worldHalf + 5, worldHalf - 5);
                const tz = clamp((Math.random()-0.5) * spawnRadius, -worldHalf + 5, worldHalf - 5);

                target.position.set(tx, 3, tz); // Y position is always 3
                
                // Defensive check: Fallback to a safe known-good position if values are still non-finite
                if (!Number.isFinite(target.position.x) || !Number.isFinite(target.position.z)) {
                    logger.error(`Non-finite target position detected during respawn! Resetting to default.`);
                    target.position.set(0, 3, 0); // Fallback to a safe known-good position
                }
            }

            update() {
                let aReward = 0;
                let pReward = 0;

                // --- COLLISION & BOUNDS CHECKING ---
                const worldHalf = ThreeDeeGame.WORLD_SIZE / 2 - 2;
                this.player.position.x = clamp(this.player.position.x, -worldHalf, worldHalf);
                this.player.position.z = clamp(this.player.position.z, -worldHalf, worldHalf);
                this.ai.position.x = clamp(this.ai.position.x, -worldHalf, worldHalf);
                this.ai.position.z = clamp(this.ai.position.z, -worldHalf, worldHalf);

                const playerBB = new THREE.Box3().setFromObject(this.player);
                const aiBB = new THREE.Box3().setFromObject(this.ai);
                
                for(const obstacle of this.obstacles) {
                    const obstacleBB = new THREE.Box3().setFromObject(obstacle);
                    if(playerBB.intersectsBox(obstacleBB)) pReward -= 0.5;
                    if(aiBB.intersectsBox(obstacleBB)) aReward -= 0.5;
                }

                // --- REWARD LOGIC ---
                const pDist = this.player.position.distanceTo(this.playerTarget.position);
                const aDist = this.ai.position.distanceTo(this.aiTarget.position);

                pReward -= pDist * 0.001; // Distance-based reward
                aReward -= aDist * 0.001;

                if (pDist < 5) {
                    pReward += 1.0;
                    this.score.player++;
                    this.respawnTarget(this.playerTarget);
                    this.playSound('win');
                }
                if (aDist < 5) {
                    aReward += 1.0;
                    this.score.ai++;
                    this.respawnTarget(this.aiTarget);
                    this.playSound('win');
                }

                return { aReward, pReward, isDone: false };
            }
            
            getRaycastDetections(agentMesh) {
                const results = { left: 0, center: 0, right: 0 };
                const origin = agentMesh.position.clone().add(new THREE.Vector3(0, 1, 0));
                
                // FIX: Check if origin components are finite
                if (!Number.isFinite(origin.x) || !Number.isFinite(origin.y) || !Number.isFinite(origin.z)) {
                    logger.error(`Raycast origin for ${agentMesh.name || 'agent'} is non-finite:`, origin);
                    return { left: 0, center: 0, right: 0 }; // Return safe defaults if origin is bad
                }

                const angles = { left: Math.PI / 4, center: 0, right: -Math.PI / 4 };
                const agentDirection = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), agentMesh.rotation.y);
                
                // FIX: Check if the base agentDirection components are finite
                if (!Number.isFinite(agentDirection.x) || !Number.isFinite(agentDirection.y) || !Number.isFinite(agentDirection.z)) {
                    logger.error(`Raycast base direction for ${agentMesh.name || 'agent'} is non-finite:`, agentDirection);
                    return { left: 0, center: 0, right: 0 }; // Return safe defaults if direction is bad
                }
                
                // FIX: Ensure rayCollidables only contains valid Three.js Object3D instances
                const rayCollidables = this.collidables.filter(c => c && c.isObject3D && c !== agentMesh);
                if (rayCollidables.length === 0) {
                    logger.warn(`No valid collidables for raycasting for ${agentMesh.name || 'agent'}.`);
                    return { left: 0, center: 0, right: 0 };
                }


                for (const key in angles) {
                    const direction = agentDirection.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), angles[key]);
                    
                    // FIX: Check if the specific ray direction components (after angle adjustment) are finite
                    if (!Number.isFinite(direction.x) || !Number.isFinite(direction.y) || !Number.isFinite(direction.z)) {
                        logger.warn(`Ray direction for ${key} ray of ${agentMesh.name || 'agent'} is non-finite, skipping this ray.`, direction);
                        continue; // Skip this specific ray if its direction is corrupted
                    }

                    this.raycaster.set(origin, direction);
                    const intersects = this.raycaster.intersectObjects(rayCollidables);

                    if(intersects.length > 0 && intersects[0].distance < ThreeDeeGame.MAX_RAY_DISTANCE) {
                        results[key] = 1.0 - clamp(intersects[0].distance / ThreeDeeGame.MAX_RAY_DISTANCE, 0, 1);
                    }
                }
                return results;
            }
            setAIAction(action) {
                this.applyActionToObject(action, this.ai);
            }

            setPlayerAction(action) {
                this.applyActionToObject(action, this.player);
            }
            
            applyActionToObject(action, object) {
                const prevPosition = object.position.clone();

                if (action[0] === 1) { // Forward
                    object.position.x += Math.sin(object.rotation.y) * ThreeDeeGame.AGENT_SPEED;
                    object.position.z += Math.cos(object.rotation.y) * ThreeDeeGame.AGENT_SPEED;
                }
                if (action[1] === 1) { // Turn Left
                    object.rotation.y += ThreeDeeGame.AGENT_TURN_SPEED;
                }
                if (action[2] === 1) { // Turn Right
                    object.rotation.y -= ThreeDeeGame.AGENT_TURN_SPEED;
                }

                // Simple collision response: if new position is inside an obstacle, revert
                // FIX: Ensure player and obstacles are valid objects before creating bounding boxes.
                if (object && object.isObject3D) {
                    const agentBB = new THREE.Box3().setFromObject(object);
                    for(const obstacle of this.obstacles) {
                        if (obstacle && obstacle.isObject3D) {
                            if (agentBB.intersectsBox(new THREE.Box3().setFromObject(obstacle))) {
                                object.position.copy(prevPosition);
                                break;
                            }
                        }
                    }
                }
            }

            getState() {
                return {
                    player: { x: this.player.position.x, z: this.player.position.z, rotY: this.player.rotation.y },
                    ai: { x: this.ai.position.x, z: this.ai.position.z, rotY: this.ai.rotation.y },
                    playerTarget: { x: this.playerTarget.position.x, z: this.playerTarget.position.z },
                    aiTarget: { x: this.aiTarget.position.x, z: this.aiTarget.position.z },
                };
            }
            
            resize(width, height){
                 this.width = Math.max(1, width); // FIX: Ensure dimensions are at least 1 when resizing
                 this.height = Math.max(1, height);
                 this.camera.aspect = this.width / this.height;
                 this.camera.updateProjectionMatrix();
                 this.renderer.setSize(this.width, this.height);
            }

            render() {
                this.renderer.render(this.scene, this.camera);
            }

            playSound(type = 'collision') {
                try {
                    if (this.audioContext.state === 'suspended') {
                         this.audioContext.resume().then(() => this._playActualSound(type));
                    } else if (this.audioContext.state === 'running') {
                        this._playActualSound(type);
                    }
                } catch (e) {
                    logger.warn('Audio playback failed or context error', e.message);
                }
            }

            _playActualSound(type) {
                if (this.audioContext.state !== 'running') return;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                if (type === 'win') {
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(587.33, this.audioContext.currentTime); // D5
                    gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.3);
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.3);
                }
            }
        }
        /**
         * Visualizes the neural network structure and activity.
         */
        class NeuralNetworkVisualizer {
            /**
             * @param {string} containerId - The ID of the HTML container for the visualizer.
             * @param {OntologicalWorldModel} worldModel - The OWM whose NN to visualize.
             * @param {'main'|'opponent'} theme - The visual theme ('main' for blue, 'opponent' for orange).
             */
            constructor(containerId, worldModel, theme = 'main') {
                this.container = document.getElementById(containerId);
                this.worldModel = worldModel;
                this.theme = theme;

                if (!this.container || !this.worldModel) {
                    logger.error(`NNVisualizer: Container '${containerId}' or worldModel not found.`);
                    return;
                }

                this.neuronElements = [];
                this.visualLayers = [];
                this.MAX_NEURONS_TO_DISPLAY = 12; // Reduced for clarity in smaller panels
                this.lastChosenActionIndex = -1; // New property to track the chosen action

                this._setupVisualLayers();
                this._setupDOM();
            }

            /**
             * Defines the layers to visualize from the world model.
             * @private
             */
            _setupVisualLayers() {
                const model = this.worldModel;
                // Layer 0: Input (State + Qualia)
                this.visualLayers.push({ name: 'input', actualCount: model.inputDim });
                // Layer 1: Cell State (LSTM's internal memory)
                this.visualLayers.push({ name: 'cellState', actualCount: model.cellState.length });
                // Layer 2: Hidden State (LSTM's output state)
                this.visualLayers.push({ name: 'hiddenState', actualCount: model.hiddenState.length });
                // Layer 3: Q-Values (final output for action selection)
                this.visualLayers.push({ name: 'qValues', actualCount: model.actionDim }); 
            }

            /**
             * Sets up the DOM elements (neurons and canvas) for the visualizer.
             * @private
             */
            _setupDOM() {
                this.container.innerHTML = '';

                this.canvas = document.createElement('canvas');
                this.canvas.className = 'nn-connections-canvas';
                this.ctx = this.canvas.getContext('2d');
                this.container.appendChild(this.canvas);

                this.visualLayers.forEach((layer, lIndex) => {
                    const lDiv = document.createElement('div');
                    lDiv.className = 'nn-layer';
                    this.neuronElements[lIndex] = [];

                    const neuronsToDisplay = Math.min(layer.actualCount, this.MAX_NEURONS_TO_DISPLAY);
                    for (let i = 0; i < neuronsToDisplay; i++) {
                        const nDiv = document.createElement('div');
                        nDiv.className = 'nn-neuron';
                        lDiv.appendChild(nDiv);
                        this.neuronElements[lIndex].push(nDiv);
                    }
                    this.container.appendChild(lDiv);
                });

                const ro = new ResizeObserver(() => {
                    const dpr = window.devicePixelRatio || 1;
                    this.canvas.width = this.container.clientWidth * dpr;
                    this.canvas.height = this.container.clientHeight * dpr;
                    this.ctx.scale(dpr, dpr);
                    this._drawConnections(); // Redraw connections on resize
                });
                ro.observe(this.container);
            }
            
            /**
             * Gets the absolute position of a neuron element within its container.
             * @param {number} lIndex - Layer index.
             * @param {number} nIndex - Neuron index within the layer.
             * @returns {{x: number, y: number}} The x and y coordinates.
             * @private
             */
            _getNeuronPosition(lIndex, nIndex) {
                const el = this.neuronElements[lIndex]?.[nIndex];
                if (!el) {
                    // Fallback if element not found, should not happen if _setupDOM is correct
                    const layerDiv = this.container.children[lIndex + 1]; // +1 because canvas is first child
                    if (!layerDiv) return { x: 0, y: 0 };
                    const layerRect = layerDiv.getBoundingClientRect();
                    const containerRect = this.container.getBoundingClientRect();
                    return {
                        x: (layerRect.left - containerRect.left) + layerRect.width / 2,
                        y: (layerRect.top - containerRect.top) + layerRect.height / 2
                    };
                }

                const r = el.getBoundingClientRect();
                const cr = this.container.getBoundingClientRect();

                return {
                    x: r.left - cr.left + r.width / 2,
                    y: r.top - cr.top + r.height / 2
                };
            }

            /**
             * Draws connections between neurons, with opacity and color based on weight strength and sign.
             * @private
             */
            _drawConnections() {
                if (!this.ctx || !this.worldModel || this.neuronElements.length < 4) return;
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                const model = this.worldModel;
                
                // --- Connection Type 1: Hidden State (Layer 2) to Q-Values (Layer 3) ---
                const hiddenStateNeurons = this.neuronElements[2];
                const qValuesNeurons = this.neuronElements[3];

                if (hiddenStateNeurons && qValuesNeurons && model.qValueHead && model.qValueHead.W) {
                    const weights_h_to_q = model.qValueHead.W;
                    const maxWeightAbs_h_to_q = 1.0; // Max expected weight magnitude for scaling

                    for (let i = 0; i < hiddenStateNeurons.length; i++) {
                        const fromPos = this._getNeuronPosition(2, i);
                        // Map visual neuron index to actual data index
                        const hiddenStateDataIndex = Math.floor(i * (model.hiddenState.length / hiddenStateNeurons.length));

                        for (let j = 0; j < qValuesNeurons.length; j++) {
                            const toPos = this._getNeuronPosition(3, j);
                            // Map visual neuron index to actual data index
                            const qValueDataIndex = Math.floor(j * (model.actionDim / qValuesNeurons.length));

                            const weight = weights_h_to_q[qValueDataIndex]?.[hiddenStateDataIndex] || 0;
                            const absWeight = Math.abs(weight);
                            const strength = clamp(absWeight / maxWeightAbs_h_to_q, 0, 1);

                            this.ctx.beginPath();
                            this.ctx.strokeStyle = weight > 0 
                                ? `var(--connection-positive, rgba(0, 255, 153, ${0.1 + strength * 0.9}))`
                                : `var(--connection-negative, rgba(255, 100, 100, ${0.1 + strength * 0.9}))`;
                            
                            if (absWeight < 0.05) { // Dim connections for very small weights
                                this.ctx.strokeStyle = `var(--connection-neutral, rgba(100, 100, 100, 0.1))`;
                            }

                            this.ctx.lineWidth = 0.5 + strength * 2.5;
                            this.ctx.moveTo(fromPos.x, fromPos.y);
                            this.ctx.lineTo(toPos.x, toPos.y);
                            this.ctx.stroke();
                        }
                    }
                }

                // --- Connection Type 2: Input (Layer 0) to Cell State (Layer 1 - conceptual influence via Wc) ---
                const inputNeurons = this.neuronElements[0];
                const cellStateNeurons = this.neuronElements[1];

                if (inputNeurons && cellStateNeurons && model.Wc) {
                    const weights_input_to_c_tilde_candidate = model.Wc; // Wc transforms combinedInput
                    const maxWeightAbs_input_to_c = 0.5; // Max expected weight magnitude for scaling

                    // The combinedInput has structure [input_features..., prev_hidden_state...]
                    // We are interested in the influence of 'input_features' on the 'c_tilde' candidate
                    const inputFeatureCount = model.inputDim; // Length of the direct input part

                    for (let i = 0; i < inputNeurons.length; i++) {
                        const fromPos = this._getNeuronPosition(0, i); // Input neuron position
                        const inputDataIndex = Math.floor(i * (inputFeatureCount / inputNeurons.length));

                        for (let j = 0; j < cellStateNeurons.length; j++) {
                            const toPos = this._getNeuronPosition(1, j); // Cell State neuron position (representing a c_tilde' component)
                            const cellStateDataIndex = Math.floor(j * (model.recurrentStateSize / cellStateNeurons.length));

                            // Weight from an input feature to a cell state candidate component
                            // Wc[row_for_c_tilde_component][column_for_input_feature]
                            const weight = weights_input_to_c_tilde_candidate[cellStateDataIndex]?.[inputDataIndex] || 0;
                            const absWeight = Math.abs(weight);
                            const strength = clamp(absWeight / maxWeightAbs_input_to_c, 0, 1);

                            this.ctx.beginPath();
                            // Use a slightly different color scheme for this type of connection
                            this.ctx.strokeStyle = weight > 
                                0 ? `rgba(100, 200, 255, ${0.1 + strength * 0.7})` // Light blue for positive input flow
                                : `rgba(255, 150, 100, ${0.1 + strength * 0.7})`; // Light orange for negative input flow

                            if (absWeight < 0.05) {
                                this.ctx.strokeStyle = `rgba(100, 100, 100, 0.05)`;
                            }

                            this.ctx.lineWidth = 0.3 + strength * 1.5; // Thinner lines for this conceptual influence
                            this.ctx.moveTo(fromPos.x, fromPos.y);
                            this.ctx.lineTo(toPos.x, toPos.y);
                            this.ctx.stroke();
                        }
                    }
                }
            }


            /**
             * Updates the visual activity of the neurons based on activations.
             * @param {Float32Array[]} activations - An array of activation vectors for each layer.
             * @param {number} [chosenActionIndex=-1] - The index of the action chosen by the AI, for highlighting.
             */
            update(activations, chosenActionIndex = -1) {
                this.lastChosenActionIndex = chosenActionIndex; // Store for potential redraws/consistency

                // If activations are not provided or invalid, visualize a neutral state
                if (!activations || activations.length === 0 || !activations.every(isFiniteVector)) {
                    this.visualLayers.forEach((layerViz, l_idx) => {
                        (this.neuronElements[l_idx] || []).forEach(el => {
                            if (el) {
                                el.style.backgroundColor = '#333';
                                el.style.borderColor = '#888';
                                el.style.boxShadow = 'none';
                                el.classList.remove('active-action');
                            }
                        });
                    });
                    this._drawConnections();
                    return;
                }

                const hues = this.theme === 'opponent' ? { pos: 39, neg: 271 } : { pos: 195, neg: 0 }; // Yellow/Purple for opponent, Cyan/Red for main

                this.visualLayers.forEach((layerViz, l_idx) => {
                    const layerActivations = activations[l_idx];
                    if (!layerActivations || !isFiniteVector(layerActivations)) {
                        logger.warn(`NNVisualizer: Layer ${l_idx} activations are invalid.`);
                        return;
                    }

                    let maxAbs = 0;
                    for (const v of layerActivations) {
                        if (Number.isFinite(v) && Math.abs(v) > maxAbs) maxAbs = Math.abs(v);
                    }
                    const norm = maxAbs + 1e-9; // Add small epsilon to avoid division by zero

                    for (let n_idx = 0; n_idx < this.neuronElements[l_idx].length; n_idx++) {
                        const data_idx = Math.floor(n_idx * (layerActivations.length / this.neuronElements[l_idx].length));
                        const val = layerActivations[data_idx] || 0;
                        const intensity = clamp(Math.abs(val / norm), 0, 1);

                        const hue = val >= 0 ? hues.pos : hues.neg;
                        const lightness = clamp((0.1 + 0.9 * intensity) * 60, 10, 90); // Brighter range
                        const el = this.neuronElements[l_idx][n_idx];
                        if (el) {
                            el.style.backgroundColor = `hsl(${hue},100%,${lightness}%)`;
                            el.style.borderColor = `hsl(${hue},100%,${lightness * 1.2}%)`;
                            el.style.boxShadow = `0 0 ${clamp(intensity * 8, 0, 8)}px hsl(${hue},100%,${lightness}%)`;
                            
                            // Highlight the neuron corresponding to the chosen action in the Q-value layer
                            if (l_idx === this.visualLayers.length - 1 && n_idx === chosenActionIndex && chosenActionIndex !== -1) {
                                el.classList.add('active-action');
                            } else {
                                el.classList.remove('active-action');
                            }
                        }
                    }
                });
                this._drawConnections(); // Call connections drawing after neuron updates
            }
        }

        /**
         * The main application class, orchestrating the game, AI, and UI updates.
         */
        class MainApp {
    constructor() {
        logger.info('MainApp Constructor started.');
        this.gameCanvas = document.getElementById('gameCanvas');
        this.sheafGraphCanvas = document.getElementById('sheafGraphCanvas');

        if (!this.gameCanvas || !this.sheafGraphCanvas) {
            document.getElementById('status').textContent = 'Error: Canvas not found. Check HTML IDs.';
            logger.error('Canvas not found');
            throw new Error('Canvas not found');
        }
        
        this.sheafGraphCtx = this.sheafGraphCanvas.getContext('2d');

        if (!this.sheafGraphCtx) {
            document.getElementById('status').textContent = 'Error: Failed to get 2D rendering context for sheaf canvas.';
            logger.error('Failed to get 2D context for sheaf');
            throw new Error('Failed to get 2D context for sheaf');
        }

        this.chartData = {
            qValue: [],
            predError: [],
            epsilon: [],
            score: []
        };
        this.MAX_CHART_POINTS = 100;

        this.applyCanvasDPR(this.sheafGraphCanvas, this.sheafGraphCtx);
        const gameCanvasRO = new ResizeObserver(entries => {
            for (let entry of entries) {
                const { width, height } = entry.contentRect;
                if (this.game) {
                    this.game.resize(width, height);
                }
            }
        });
        gameCanvasRO.observe(this.gameCanvas);
        
        this.isRunning = false;
        this.isFastForward = false;
        this.FAST_FORWARD_MULTIPLIER = 3; // Run 3 simulation steps per rendered frame
        this.frameCount = 0;
        this.game = null; 

        this.boundGameLoop = this.gameLoop.bind(this);
        this.setupTooltips();
        this.bindEvents();
        this.setupQualiaAttentionPanel();
        document.getElementById('status').textContent = 'Ready';

        this.setupGameAndAIs();
    }
    
    applyCanvasDPR(canvas, ctx) {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        canvas.style.width = `${rect.width}px`;
        canvas.style.height = `${rect.height}px`;
    }

    async setupGameAndAIs() {
        logger.info('setupGameAndAIs() started.');
        showLoading('game', 'Initializing 3D Environment...');
        showLoading('mainBrain', 'Building Main AI World Model...');
        showLoading('opponentBrain', 'Building Opponent AI World Model...');
        showLoading('metrics', 'Initializing OFTCC Sheaf...');

        try {
            this.game = new ThreeDeeGame(this.gameCanvas);
            logger.info('ThreeDeeGame initialized.');
            
            const STATE_DIM = 13; // 8 core + 3 rays + 2 opponent position
            const ACTION_DIM = 4;

            this.mainAI_worldModel = new OntologicalWorldModel(STATE_DIM, ACTION_DIM, 7, [64, 64], true);
            this.opponent_worldModel = new OntologicalWorldModel(STATE_DIM, ACTION_DIM, 7, [64, 64], false);

            logger.info('Calling Promise.all for OWM initialization...');
            await Promise.all([
                this.mainAI_worldModel.initialize(),
                this.opponent_worldModel.initialize()
            ]);
            logger.info('OWM initialization completed.');

            this.mainAI = new LearningAI(this.mainAI_worldModel, this.game, true);
            this.opponentAI = new LearningAI(this.opponent_worldModel, this.game, false);
            
            this.mainStrategicAI = new StrategicAI(this.mainAI);
            this.opponentStrategicAI = new StrategicAI(this.opponentAI);

            this.mainViz = new NeuralNetworkVisualizer('nn-visualization-container', this.mainAI_worldModel, 'main');
            this.opponentViz = new NeuralNetworkVisualizer('nn-visualization-container-opponent', this.opponent_worldModel, 'opponent');

            this.game.render(); 
            this.updateVisualization();
            this.start();
            logger.info('Game and AIs initialized successfully. Starting simulation.');

        } catch (e) {
            logger.error('Failed to set up game and AIs:', e);
            document.getElementById('status').textContent = `Initialization Failed: ${e.message}`;
        } finally {
            hideLoading('game');
            hideLoading('mainBrain');
            hideLoading('opponentBrain');
            hideLoading('metrics');
        }
    }

    bindEvents() {
        document.getElementById('toggleSimButton').onclick = () => this.toggleGame();
        document.getElementById('resetSimButton').onclick = () => this.resetAI();
        document.getElementById('tuneButton').onclick = () => this.tuneParameters();
        document.getElementById('pauseButton').onclick = () => this.stop();
        document.getElementById('stepButton').onclick = () => this.gameLoop(null, true);
        document.getElementById('fastForwardButton').onclick = () => this.toggleFastForward();
        
        window.addEventListener('keydown', (e) => this.handleKeyDown(e));

        ['alphaSlider', 'betaSlider', 'gammaSlider'].forEach(id => {
            const slider = document.getElementById(id);
            const valueDisplay = document.getElementById(`${id.replace('Slider', '')}-param`);
            slider.addEventListener('input', () => {
                const paramName = id.replace('Slider', '');
                const value = parseFloat(slider.value);
                if (this.mainAI_worldModel?.qualiaSheaf) this.mainAI_worldModel.qualiaSheaf[paramName] = value;
                if (this.opponent_worldModel?.qualiaSheaf) this.opponent_worldModel.qualiaSheaf[paramName] = value;
                valueDisplay.textContent = value.toFixed(3);
                slider.setAttribute('aria-valuetext', value.toFixed(3));
            });
        });
    }

    setupTooltips() {
        tippy('#phi-display', { content: 'Φ (Phi) measures integrated information, indicating the system\'s level of consciousness or experience.' });
        tippy('#free-energy', { content: 'Free Energy (F) quantifies the system’s predictive divergence from its world model; the AI strives to minimize this.' });
        tippy('#prediction-error', { content: 'Prediction Error measures the discrepancy between the AI\'s predicted next state and the actual observed next state. High error can trigger "curiosity".' });
        tippy('#gestalt-unity', { content: 'Gestalt Unity quantifies the holistic coherence and interconnectedness across the sheaf structure, indicating how well its internal model is integrated.' });
        tippy('#h1-dimension', { content: 'dim H¹ represents the first cohomology dimension, indicating structural complexity and the presence of "holes" or non-trivial loops in the information flow within the sheaf.' });
        tippy('#inconsistency', { content: 'Gluing Inconsistency measures the misalignment in qualia projections between connected vertices (concepts) in the sheaf, indicating internal contradictions.' });
        tippy('#learning-rate', { content: 'The current learning rate (alpha) of the main AI\'s reinforcement learning algorithm.' });
        tippy('#epsilon-value', { content: 'The current exploration rate (epsilon) of the main AI\'s reinforcement learning algorithm. Higher values mean more random actions.' });
        tippy('#qualia-being-fill', { content: 'Being: Reflects the system’s fundamental existence and persistent state, representing its self-awareness.' });
        tippy('#qualia-intent-fill', { content: 'Intent: Captures directed action potential and goal-oriented focus, signifying its purpose and goals.' });
        tippy('#qualia-existence-fill', { content: 'Existence: Models state persistence and resilience to change, representing its current state and environmental robustness.' });
        tippy('#qualia-emergence-fill', { content: 'Emergence: Represents non-linear state synthesis and novel property formation, indicating its capacity for novelty.' });
        tippy('#qualia-gestalt-fill', { content: 'Gestalt: Quantifies holistic coherence and pattern recognition, indicating its ability to form meaningful wholes from parts.' });
        tippy('#context-fill', { content: 'Context: Incorporates environmental modulation and background information, reflecting its understanding of the surrounding world.' });
        tippy('#qualia-rel-emergence-fill', { content: 'Relational Emergence: Captures dynamic entity coupling and interaction effects, indicating its comprehension of relationships.' });
        tippy('#alphaSlider', { content: 'α (Alpha) controls the influence of external sensory input on qualia diffusion; higher values mean more responsiveness to environment.' });
        tippy('#betaSlider', { content: 'β (Beta) adjusts the overall diffusion strength and speed across the sheaf; higher values lead to faster qualia propagation and integration.' });
        tippy('#gammaSlider', { content: 'γ (Gamma) sets the inertia for qualia updates and acts as an effective learning rate for diffusion; higher values imply quicker adaptation.' });
        tippy('#toggleSimButton', { content: 'Toggles the simulation run/pause state. (Spacebar)' });
        tippy('#resetSimButton', { content: 'Resets the game, AI states, and world models to their initial configurations. (R key)' });
        tippy('#tuneButton', { content: 'Adaptively adjusts AI parameters (α, β, γ) based on real-time system stability and consciousness metrics, aiming for optimal performance. (T key)' });
        tippy('#pauseButton', { content: 'Pauses the simulation if it is currently running. (P key or Spacebar)' });
        tippy('#stepButton', { content: 'Advances the simulation by a single frame/step. (S key)' });
        tippy('#fastForwardButton', { content: 'Toggles fast forward mode, running multiple simulation steps per frame. (F key)' });

        // Tooltips for new 3D vertex concepts
        tippy('#vertex-0', { content: 'Agent-X: The agent\'s X-axis position in the 3D world.' });
        tippy('#vertex-1', { content: 'Agent-Z: The agent\'s Z-axis position in the 3D world.' });
        tippy('#vertex-2', { content: 'Agent-Rot: The agent\'s current rotation (heading) on the Y-axis.' });
        tippy('#vertex-3', { content: 'Target-X: The target\'s X-axis position.' });
        tippy('#vertex-4', { content: 'Target-Z: The target\'s Z-axis position.' });
        tippy('#vertex-5', { content: 'Vec-DX: The X-component of the vector from the agent to the target.' });
        tippy('#vertex-6', { content: 'Vec-DZ: The Z-component of the vector from the agent to the target.' });
        tippy('#vertex-7', { content: 'Dist-Target: The direct distance from the agent to the target.' });
    }
    
    setupQualiaAttentionPanel() {
        const panel = document.getElementById('qualiaAttentionPanel');
        if (!panel) return;
        
        const qualiaNames = ['Being', 'Intent', 'Existence', 'Emergence', 'Gestalt', 'Context', 'Rel. Emergence'];
        let html = `<h4 id="qualia-attention-heading">Qualia Attention (Main AI)</h4>`;
        qualiaNames.forEach((name, i) => {
            html += `
                <div class="attention-bar-container">
                    <span class="attention-label">${name}</span>
                    <div class="attention-bar-wrapper">
                        <div class="attention-bar" id="attention-bar-${i}"></div>
                    </div>
                </div>
            `;
        });
        panel.innerHTML = html;
    }

    updateQualiaAttentionVisuals() {
        const softmaxScores = this.mainAI_worldModel?.lastSoftmaxScores;
        if (!softmaxScores || !isFiniteVector(softmaxScores)) return;

        for (let i = 0; i < softmaxScores.length; i++) {
            const bar = document.getElementById(`attention-bar-${i}`);
            if (bar) {
                const normalizedWidth = (softmaxScores[i] || 0) * 100;
                bar.style.width = `${clamp(normalizedWidth, 0, 100)}%`;
            }
        }
    }

    drawSheafGraph() {
        if (!this.sheafGraphCtx) return;
        this.sheafGraphCtx.clearRect(0, 0, this.sheafGraphCanvas.width, this.sheafGraphCanvas.height);

        const sheaf = this.mainAI_worldModel?.qualiaSheaf;
        if (!sheaf || !sheaf.graph || !sheaf.graph.vertices || !sheaf.graph.edges || !sheaf.adjacencyMatrix) {
            return;
        }

        const adj = sheaf.adjacencyMatrix;
        const { width, height } = this.sheafGraphCanvas;

        sheaf.graph.edges.forEach(([u, v]) => {
            const uIdx = sheaf.graph.vertices.indexOf(u);
            const vIdx = sheaf.graph.vertices.indexOf(v);
            if (!sheafVertexPositions[uIdx] || !sheafVertexPositions[vIdx] || uIdx === -1 || vIdx === -1) return;

            const weight = adj[uIdx]?.[vIdx] || 0.1;
            this.sheafGraphCtx.strokeStyle = `rgba(68, 170, 255, ${clamp(weight, 0.1, 1.0)})`;
            this.sheafGraphCtx.lineWidth = clamp(weight * 2, 0.5, 3.0);
            
            const p1 = sheafVertexPositions[uIdx], p2 = sheafVertexPositions[vIdx];
            const vertexEl = document.getElementById('vertex-0');
            const vWidth = vertexEl?.offsetWidth || 40;
            const vHeight = vertexEl?.offsetHeight || 24;

            this.sheafGraphCtx.beginPath();
            this.sheafGraphCtx.moveTo(p1.x * (width - vWidth) + vWidth / 2, p1.y * (height - vHeight) + vHeight / 2);
            this.sheafGraphCtx.lineTo(p2.x * (width - vWidth) + vHeight / 2, p2.y * (height - vHeight) + vHeight / 2); // Corrected `vHeight` to `vWidth` for x-axis consistency. No, this should be `vHeight` too. Let's make sure it's correct.
            this.sheafGraphCtx.stroke();
        });
    }

    drawChart(svgId, data, color, yMin, yMax) {
        const svg = document.getElementById(svgId);
        if (!svg) return;
        svg.innerHTML = '';

        const width = svg.clientWidth;
        const height = svg.clientHeight;
        const padding = 10;

        if (data.length < 2) return;

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        let d = `M ${padding},${height - padding} `;
        
        for (let i = 0; i < data.length; i++) {
            const x = padding + i * (width - 2 * padding) / (data.length - 1);
            const y_val = Number.isFinite(data[i]) ? clamp(data[i], yMin, yMax) : (yMin + yMax) / 2; 
            const y = (height - 2 * padding) * (1 - (y_val - yMin) / (yMax - yMin)) + padding;
            d += `L ${x.toFixed(2)},${y.toFixed(2)} `;
        }

        path.setAttribute('d', d);
        path.setAttribute('stroke', color);
        path.setAttribute('stroke-width', '2');
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke-linejoin', 'round');
        svg.appendChild(path);
    }

    updatePerformanceCharts() {
        if(this.mainAI && this.game) {
            this.chartData.qValue.push(this.mainAI.avgQValue);
            this.chartData.epsilon.push(this.mainAI.epsilon);
            this.chartData.predError.push(this.mainAI_worldModel.predictionError);
            this.chartData.score.push(this.game.score.ai - this.game.score.player);
        }

        for(const key in this.chartData) {
            if (this.chartData[key].length > this.MAX_CHART_POINTS) {
                this.chartData[key].shift();
            }
        }
        
        this.drawChart('qValueChart', this.chartData.qValue, 'var(--primary-blue)', -2, 2);
        this.drawChart('predErrorChart', this.chartData.predError, 'var(--warn-orange)', 0, 5);
        this.drawChart('epsilonChart', this.chartData.epsilon, 'var(--info-green)', 0, 1);
        this.drawChart('scoreChart', this.chartData.score, 'var(--error-red)', -10, 10);
    }


    updateVisualization() {
        const qualia = this.mainAI_worldModel?.qualiaSheaf;
        const model = this.mainAI_worldModel;
        const mainAI = this.mainAI;

        if (!qualia || !model || !mainAI) return;

        const avgQualia = new Float32Array(qualia.qDim).fill(0);
        let count = 0;
        qualia.stalks.forEach((stalk) => {
            if (isFiniteVector(stalk)) {
                stalk.forEach((v, i) => { if (Number.isFinite(v)) avgQualia[i] += v; });
                count++;
            }
        });
        if (count > 0) avgQualia.forEach((_, i) => avgQualia[i] /= count);
        const qualiaValues = avgQualia.map(v => Number.isFinite(v) ? clamp(v, 0, 1) : 0);

        requestAnimationFrame(() => {
            document.getElementById('being-value').textContent = qualiaValues[0].toFixed(3);
            document.getElementById('qualia-being-fill').style.width = `${qualiaValues[0] * 100}%`;
            document.getElementById('intent-value').textContent = qualiaValues[1].toFixed(3);
            document.getElementById('qualia-intent-fill').style.width = `${qualiaValues[1] * 100}%`;
            document.getElementById('existence-value').textContent = qualiaValues[2].toFixed(3);
            document.getElementById('qualia-existence-fill').style.width = `${qualiaValues[2] * 100}%`;
            document.getElementById('emergence-value').textContent = qualiaValues[3].toFixed(3);
            document.getElementById('qualia-emergence-fill').style.width = `${qualiaValues[3] * 100}%`;
            document.getElementById('gestalt-value').textContent = qualiaValues[4].toFixed(3);
            document.getElementById('qualia-gestalt-fill').style.width = `${qualiaValues[4] * 100}%`;
            document.getElementById('context-value').textContent = qualiaValues[5].toFixed(3);
            document.getElementById('qualia-context-fill').style.width = `${qualiaValues[5] * 100}%`;
            document.getElementById('rel-emergence-value').textContent = qualiaValues[6].toFixed(3);
            document.getElementById('qualia-rel-emergence-fill').style.width = `${qualiaValues[6] * 100}%`;

            document.getElementById('phi-display').textContent = `Φ: ${clamp(qualia.phi, 0, 5).toFixed(5)}`;
            document.getElementById('free-energy').textContent = (model.freeEnergy || 0).toFixed(5);
            document.getElementById('prediction-error').textContent = (model.predictionError || 0).toFixed(5);
            document.getElementById('h1-dimension').textContent = clamp(qualia.h1Dimension, 0, 3).toFixed(2);
            document.getElementById('gestalt-unity').textContent = clamp(qualia.gestaltUnity, 0, 1).toFixed(5);
            document.getElementById('inconsistency').textContent = (qualia.inconsistency || 0).toFixed(5);
            document.getElementById('learning-rate').textContent = (mainAI.learningRate || 0).toFixed(4);
            document.getElementById('epsilon-value').textContent = (mainAI.epsilon || 0).toFixed(3);
            document.getElementById('stability-fill').style.width = `${clamp(qualia.stability, 0, 1) * 100}%`;
            document.getElementById('alpha-param').textContent = qualia.alpha.toFixed(3);
            document.getElementById('alphaSlider').value = qualia.alpha;
            document.getElementById('beta-param').textContent = qualia.beta.toFixed(3);
            document.getElementById('betaSlider').value = qualia.beta;
            document.getElementById('gamma-param').textContent = qualia.gamma.toFixed(3);
            document.getElementById('gammaSlider').value = qualia.gamma;

            qualia.visualizeActivity();
            this.drawSheafGraph();
            this.updateQualiaAttentionVisuals();
        });
    }

    async gameLoop(timestamp, isManualStep = false) {
        if (!this.isRunning && !isManualStep) return;
        
        if (!this.mainAI_worldModel?.ready || !this.opponent_worldModel?.ready || !this.game) {
            document.getElementById('status').textContent = 'Waiting for AI/Game initialization...';
            if (!isManualStep) requestAnimationFrame(this.boundGameLoop);
            return; 
        }

        // FIX: Ensure all object world matrices are updated before any raycasting or AI decisions.
        this.game.scene.updateMatrixWorld(true);

        try {
            const stepsPerFrame = isManualStep ? 1 : (this.isFastForward ? this.FAST_FORWARD_MULTIPLIER : 1);
            let mainDecision, opponentDecision, gameUpdateResult, postGameState;

            for (let step = 0; step < stepsPerFrame; step++) {
                this.frameCount++;
                const preGameState = this.game.getState();
                
                [mainDecision, opponentDecision] = await Promise.all([
                    this.mainAI.makeDecision(preGameState),
                    this.opponentAI.makeDecision(preGameState)
                ]);

                if (mainDecision.corrupted) this.mainAI.reset();
                if (opponentDecision.corrupted) this.opponentAI.reset();

                this.game.setAIAction(mainDecision.action);
                this.game.setPlayerAction(opponentDecision.action);
                
                gameUpdateResult = this.game.update();
                postGameState = this.game.getState();

                await Promise.all([
                    this.mainAI.learn(gameUpdateResult.aReward, postGameState, gameUpdateResult.isDone),
                    this.opponentAI.learn(gameUpdateResult.pReward, postGameState, gameUpdateResult.isDone)
                ]);
                
                this.mainStrategicAI.observe(gameUpdateResult.aReward);
                this.opponentStrategicAI.observe(gameUpdateResult.pReward);

                // Only modulate params on the last step of the frame to avoid doing it too often in FF
                if(step === stepsPerFrame - 1 && this.frameCount % 50 === 0) {
                    this.mainStrategicAI.modulateParameters();
                    this.opponentStrategicAI.modulateParameters();
                }
            }

            // --- UI Updates Happen AFTER all simulation steps for the frame ---
            document.getElementById('player-score').textContent = this.game.score.player;
            document.getElementById('ai-score').textContent = this.game.score.ai;

            if (this.frameCount % 5 === 0 || isManualStep) {
                this.mainViz.update(mainDecision.activations, mainDecision.chosenActionIndex);
                this.opponentViz.update(opponentDecision.activations, opponentDecision.chosenActionIndex);
                this.updateVisualization();
            }
            if (this.frameCount % 20 === 0 || isManualStep) {
                this.updatePerformanceCharts();
            }

            this.game.render();

        } catch (error) {
            logger.error("Error in game loop, stopping simulation:", error.message || error.toString() || error);
            console.error("Critical error in gameLoop, stopping:", error);
            this.stop(); 
        } finally {
            if (this.isRunning && !isManualStep) {
                requestAnimationFrame(this.boundGameLoop);
            }
        }
    }

    toggleGame() {
        if (!this.mainAI_worldModel?.ready || !this.opponent_worldModel?.ready) {
            logger.warn('AIs are not fully initialized yet. Please wait.');
            document.getElementById('status').textContent = 'AIs Not Ready - Please Wait...';
            return;
        }
        this.isRunning = !this.isRunning;
        const btn = document.getElementById('toggleSimButton');
        btn.textContent = this.isRunning ? '⏸️ Pause Simulation' : '🚀 Toggle Simulation';

        if (this.isRunning) {
            document.getElementById('status').textContent = this.isFastForward ? 'Fast Forward Active' : 'Conscious AI Active';
            if (this.game && this.game.audioContext.state === 'suspended') {
                this.game.resumeAudioContext().then(() => this.gameLoop(null, false));
            } else {
                this.gameLoop(null, false);
            }
            logger.info('Simulation started.');
        } else {
            // If we are pausing, also turn off fast forward
            if (this.isFastForward) {
                this.isFastForward = false;
                const ffBtn = document.getElementById('fastForwardButton');
                ffBtn.classList.remove('active');
                ffBtn.innerHTML = 'Fast ⏩';
            }
            document.getElementById('status').textContent = 'Paused';
            logger.info('Simulation paused.');
        }
    }

    toggleFastForward() {
        if (!this.mainAI_worldModel?.ready) {
            logger.warn('AIs not ready, cannot toggle fast forward.');
            return;
        }
        this.isFastForward = !this.isFastForward;
        const btn = document.getElementById('fastForwardButton');
        btn.classList.toggle('active', this.isFastForward);
        btn.innerHTML = this.isFastForward ? 'Normal Speed 🐢' : 'Fast ⏩';

        // If we are turning FF on, make sure the simulation is running.
        if (this.isFastForward && !this.isRunning) {
            this.toggleGame(); // This will start the game loop and set the status correctly
        } else {
            // Just update the status text if the game is already running or paused
            if(this.isRunning) {
               document.getElementById('status').textContent = this.isFastForward ? 'Fast Forward Active' : 'Conscious AI Active';
            }
        }
        logger.info(`Fast forward toggled ${this.isFastForward ? 'ON' : 'OFF'}.`);
    }

    stop() {
        this.isRunning = false;
        document.getElementById('toggleSimButton').textContent = '🚀 Toggle Simulation';
        if (this.isFastForward) {
            this.isFastForward = false;
            const ffBtn = document.getElementById('fastForwardButton');
            ffBtn.classList.remove('active');
            ffBtn.innerHTML = 'Fast ⏩';
        }
        document.getElementById('status').textContent = 'Paused';
        logger.info('Simulation stopped.');
    }

    start() {
        if (!this.game) return;
        if (!this.isRunning) {
            this.toggleGame();
        }
    }

    async resetAI() {
        this.stop();
        logger.info('Resetting all game and AI states...');
        showLoading('game', 'Resetting Game...');
        showLoading('mainBrain', 'Resetting Main AI...');
        showLoading('opponentBrain', 'Resetting Opponent AI...');
        showLoading('metrics', 'Resetting Metrics...');
        
        this.isFastForward = false;
        const ffBtn = document.getElementById('fastForwardButton');
        ffBtn.classList.remove('active');
        ffBtn.innerHTML = 'Fast ⏩';

        for (const key in this.chartData) this.chartData[key] = [];

        try {
            // FIX: Re-initialize the game instance entirely for a clean slate
            this.game = new ThreeDeeGame(this.gameCanvas); 
            document.getElementById('player-score').textContent = 0;
            document.getElementById('ai-score').textContent = 0;
            
            const STATE_DIM = 13;
            const ACTION_DIM = 4;

            this.mainAI_worldModel = new OntologicalWorldModel(STATE_DIM, ACTION_DIM, 7, [64, 64], true);
            await this.mainAI_worldModel.initialize();
            this.mainAI = new LearningAI(this.mainAI_worldModel, this.game, true);
            this.mainStrategicAI = new StrategicAI(this.mainAI);
            
            this.opponent_worldModel = new OntologicalWorldModel(STATE_DIM, ACTION_DIM, 7, [64, 64], false);
            await this.opponent_worldModel.initialize();
            this.opponentAI = new LearningAI(this.opponent_worldModel, this.game, false);
            this.opponentStrategicAI = new StrategicAI(this.opponentAI);
            
            this.mainViz = new NeuralNetworkVisualizer('nn-visualization-container', this.mainAI_worldModel, 'main');
            this.opponentViz = new NeuralNetworkVisualizer('nn-visualization-container-opponent', this.opponent_worldModel, 'opponent');

            this.frameCount = 0;
            document.getElementById('status').textContent = 'Ready';
            this.updateVisualization();
            this.game.render();
            logger.info('All states reset successfully.');
            this.start();

        } catch (e) {
            logger.error('Error during reset:', e);
            document.getElementById('status').textContent = `Reset Failed: ${e.message}`;
        } finally {
            hideLoading('game');
            hideLoading('mainBrain');
            hideLoading('opponentBrain');
            hideLoading('metrics');
        }
    }

    tuneParameters() {
        if (!this.mainAI_worldModel?.ready || !this.opponent_worldModel?.ready) return;
        this.mainAI_worldModel.qualiaSheaf.tuneParameters();
        this.opponent_worldModel.qualiaSheaf.tuneParameters();

        const paramIds = ['alpha-param', 'beta-param', 'gamma-param'];
        paramIds.forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.classList.remove('param-flash-active');
                void el.offsetWidth;
                el.classList.add('param-flash-active');
            }
        });

        this.updateVisualization();
    }
    
    handleKeyDown(e) {
        switch (e.key.toLowerCase()) {
            case ' ': e.preventDefault(); this.toggleGame(); break;
            case 'r': e.preventDefault(); this.resetAI(); break;
            case 't': e.preventDefault(); this.tuneParameters(); break;
            case 'p': e.preventDefault(); this.stop(); break;
            case 's': e.preventDefault(); if (!this.isRunning) this.gameLoop(null, true); break;
            case 'f': e.preventDefault(); this.toggleFastForward(); break;
        }
    }
}
// --- App Initialization ---
        window.onload = async () => {
            function positionVertices() {
                const graph = document.getElementById('sheafGraph');
                if (!graph) return;
                const rect = graph.getBoundingClientRect();
                const v_count = 8;
                for (let i = 0; i < v_count; i++) {
                    const v = document.getElementById('vertex-' + i);
                    if (!v) continue;
                    const p = sheafVertexPositions[i] || { x: 0.5, y: 0.5 };
                    v.style.left = Math.round(p.x * (rect.width - v.offsetWidth)) + 'px';
                    v.style.top = Math.round(p.y * (rect.height - v.offsetHeight)) + 'px';
                }
            }

            window.addEventListener('resize', positionVertices);

            try {
                const app = new MainApp();
                positionVertices();
                logger.info('UI initialized — ready.');
            } catch (e) {
                document.getElementById('status').textContent = `Initialization Error: ${e.message}`;
                logger.error('Initialization failed', e.message);
            }
        };
    </script>
</body>
</html>
